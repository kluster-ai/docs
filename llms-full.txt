# kluster.ai llms-full.txt
kluster.ai. kluster.ai provides the technology to verify and trust AI responses in real time. Developers can validate outputs, detect hallucinations, and ensure response reliability across any model, with minimal integration effort.

## Generated automatically. Do not edit directly.

Documentation: https://docs.kluster.ai

## List of doc pages:
Doc-Page: https://raw.githubusercontent.com/kluster-ai/docs/main/verify/code/integrations.md
Doc-Page: https://raw.githubusercontent.com/kluster-ai/docs/main/verify/code/overview.md
Doc-Page: https://raw.githubusercontent.com/kluster-ai/docs/main/verify/code/quickstart.md
Doc-Page: https://raw.githubusercontent.com/kluster-ai/docs/main/verify/code/tools.md
Doc-Page: https://raw.githubusercontent.com/kluster-ai/docs/main/verify/get-api-key.md
Doc-Page: https://raw.githubusercontent.com/kluster-ai/docs/main/verify/mcp/client-integrations.md
Doc-Page: https://raw.githubusercontent.com/kluster-ai/docs/main/verify/mcp/cloud/api.md
Doc-Page: https://raw.githubusercontent.com/kluster-ai/docs/main/verify/mcp/cloud/platform.md
Doc-Page: https://raw.githubusercontent.com/kluster-ai/docs/main/verify/mcp/get-started.md
Doc-Page: https://raw.githubusercontent.com/kluster-ai/docs/main/verify/mcp/overview.md
Doc-Page: https://raw.githubusercontent.com/kluster-ai/docs/main/verify/mcp/sdk-integrations/openai-agents.md
Doc-Page: https://raw.githubusercontent.com/kluster-ai/docs/main/verify/mcp/self-hosted.md
Doc-Page: https://raw.githubusercontent.com/kluster-ai/docs/main/verify/mcp/tools.md
Doc-Page: https://raw.githubusercontent.com/kluster-ai/docs/main/verify/openai-compatibility.md
Doc-Page: https://raw.githubusercontent.com/kluster-ai/docs/main/verify/overview.md
Doc-Page: https://raw.githubusercontent.com/kluster-ai/docs/main/verify/quickstart/reliability.md
Doc-Page: https://raw.githubusercontent.com/kluster-ai/docs/main/verify/reliability/chat-completion.md
Doc-Page: https://raw.githubusercontent.com/kluster-ai/docs/main/verify/reliability/overview.md
Doc-Page: https://raw.githubusercontent.com/kluster-ai/docs/main/verify/reliability/verify-api.md
Doc-Page: https://raw.githubusercontent.com/kluster-ai/docs/main/verify/reliability/workflow-integrations.md

## Full content for each doc page

Doc-Content: https://docs.kluster.aiverify/code/integrations/
--- BEGIN CONTENT ---
---
title: Integrations for Code Verify
description: Set up kluster.ai code checks in your IDE via MCP. One-click install for Cursor, or manually configure Claude Code & other MCP-compatible tools.
---

# Integrations

The [kluster.ai](https://www.kluster.ai/){target=_blank} Code verification service is designed to integrate directly into your IDE workflow, providing real-time code analysis as you develop. By leveraging MCP, Code verification works seamlessly with AI coding assistants to catch issues before they reach your codebase.

For Cursor users, a one-click installation process is available that handles all setup automatically. See the [Code Quick Start guide](/verify/code/quickstart/){target=_blank} for the fastest way to get started.

## Prerequisites

Before getting started, ensure you have:

-- **A kluster.ai account**: Sign up on the [kluster.ai platform](https://platform.kluster.ai/signup){target=\_blank} if you don't have one.
- **A kluster.ai API key**: After signing in, go to the [**API Keys**](https://platform.kluster.ai/apikeys){target=\_blank} section and create a new key. For detailed instructions, check out the [Get an API key](/verify/get-api-key/){target=\_blank} guide.

## Supported IDEs

Code verification works with any MCP-compatible client, including:

- **Cursor**: One-click installation with automatic MCP server setup (most popular).
- **Windsurf**: AI coding assistant with Cascade and MCP integration.
- **Kilo Code**: AI coding assistant with streamlined MCP configuration.
- **Claude Code**: Manual MCP configuration via `.claude/mcp.json`.
- **Cline**: Open-source AI coding agent for VS Code with MCP marketplace.
- **Roo Code**: AI-powered dev team extension with dual configuration support.
- **Any MCP-compatible IDE**: Manual configuration using the MCP server details below.

## MCP configuration

Add the following to your MCP configuration file:

```json
{  
    "mcpServers": {  
        "Kluster-Verify-Code-MCP": {  
            "command": "npx",  
            "args": [  
                "@klusterai/kluster-verify-code-mcp@latest"  
            ],  
            "env": {  
                "KLUSTER_API_KEY": "your-api-key-here"  
            }  
        }  
    }  
}  
```

## Setup instructions

=== "Cursor"

    One-click installation (recommended):
    
    For the fastest setup, use our one-click installation process described in the [Get started with Verify Code](/verify/code/quickstart/){target=\_blank} guide.
    
    Manual configuration:
    
    1. Open **Cursor Settings** by clicking the gear icon on the top right corner.
    
    2. Navigate to **Tools & Integrations** in the left sidebar.
    
    3. Under **MCP Tools**, click **Add Custom MCP**.
    
        ![Cursor Settings - Tools & Integrations](/images/verify/code/integrations/cursor/cursor-integration-1.webp)
    
    4. This opens the `mcp.json` configuration file. Add the `Kluster-Verify-Code-MCP` server configuration:
    
        ![MCP Configuration File](/images/verify/code/integrations/cursor/cursor-integration-2.webp)
    
    5. Save the configuration file and return to **Cursor Settings**.
    
    The **Kluster-Verify-Code-MCP** server will now appear with both tools enabled:

    - **`kluster_code_review_auto`**: For code security and quality verification.
    - **`kluster_frameworks_check_tool`**: For dependency validation.
      
    ![Active MCP Tools](/images/verify/code/integrations/cursor/cursor-integration-3.webp)

=== "Windsurf"

    1. Open Settings by clicking the gear icon or using the command palette.

    2. Click **Windsurf Settings**.
    
        ![Windsurf Settings](/images/verify/code/integrations/windsurf/windsurf-integration-1.webp)
    
    3. Navigate to **Cascade** in the left sidebar. 
    
    4. Select **Manage MCPs** to access the MCP configuration.
    
        ![Cascade MCP Settings](/images/verify/code/integrations/windsurf/windsurf-integration-2.webp)
        
    5. Click **View raw config** to access the MCP configuration file.
    
        ![Manage MCP Servers](/images/verify/code/integrations/windsurf/windsurf-integration-3.webp)

    6. Add the `Kluster-Verify-Code-MCP` configuration to your `mcp_config.json`:
    
        ![MCP Configuration](/images/verify/code/integrations/windsurf/windsurf-integration-4.webp)
    
    7. Save the configuration and refresh. 
      
    The **Kluster-Verify-Code-MCP** will appear with both tools enabled:
      
    - **`kluster_code_review_auto`**: For code security and quality verification.
    - **`kluster_frameworks_check_tool`**: For dependency validation.
    
    ![Active MCP Tools](/images/verify/code/integrations/windsurf/windsurf-integration-5.webp)

=== "Kilo Code"

    1. Open Settings and navigate to **MCP Servers**.
    
    2. Select the **Installed** tab.

    3. Click **Edit Project MCP** to open the MCP configuration.

    4. Paste the content of the MCP config shown above with your API key.
        
      ![MCP Servers Settings](/images/verify/code/integrations/kilo/kilo-integration-1.webp)
    
    Then you should see the installed **Kluster-Verify-Code-MCP** server with both tools enabled:

       - **`kluster_code_review_auto`**: For code security and quality verification.
       - **`kluster_frameworks_check_tool`**: For dependency validation.
    
    ![Kluster MCP Tools](/images/verify/code/integrations/kilo/kilo-integration-2.webp)

=== "Claude Code"

    1. Create or edit `.claude/mcp.json` in your project.
    2. Add the Code MCP server configuration shown above with your API key.
    3. Restart Claude Code and the tools will be available immediately.
    4. Run the command `/mcp` to check the status of the tools. 

    ![MCP Code Verify installed in claude code](/images/verify/code/integrations/claudecode/claudecode-integration-1.webp)

=== "Cline"

    1. Open Cline and click **MCP Servers** in the left sidebar.
    
    2. Select the **Installed** tab.
    
    3. Click on **Configure MCP Servers**, which will open the `cline_mcp_settings.json` configuration file. Add the `Kluster-Verify-Code-MCP` server configuration.

        ![Cline MCP Settings](/images/verify/code/integrations/cline/cline-integration-1.webp)
    
    4. Save the configuration.
    
    The **Kluster-Verify-Code-MCP** server will now appear with both tools enabled:

    - **`kluster_code_review_auto`**: For code security and quality verification.
    - **`kluster_frameworks_check_tool`**: For dependency validation.

    ![MCP Configuration File](/images/verify/code/integrations/cline/cline-integration-2.webp)

=== "Roo Code"

    1. Open Roo Code and click on **MCP Servers** in the left sidebar.
    
    2. Click **Edit Project MCP** to open the MCP configuration for your project.
    
        ![MCP Servers Menu](/images/verify/code/integrations/roocode/roocode-integration-1.webp)
    
    3. The configuration file will open at `.roo/mcp_settings.json`. Add the `Kluster-Verify-Code-MCP` server configuration shown above.
    
    4. Save the file.
    
    The **Kluster-Verify-Code-MCP** server will appear with both tools enabled:

    - `kluster_code_review_auto`: For code security and quality verification.
    - `kluster_frameworks_check_tool`: For dependency validation.
    
    ![Active MCP Tools](/images/verify/code/integrations/roocode/roocode-integration-2.webp)    

=== "Other MCP Clients"

    For any other MCP-compatible IDE or client:
    
    1. Locate your MCP configuration file (varies by client).
    2. Add the Code MCP server configuration shown above.
    3. Restart your IDE if required by the client.
    4. The tools should now be available in your AI assistant.

## Available tools

For detailed information about each tool, see our [Tools reference](/verify/code/tools/).
--- END CONTENT ---

Doc-Content: https://docs.kluster.aiverify/code/overview/
--- BEGIN CONTENT ---
---
title: Code Verification Using Verify
description: Learn how to use kluster.ai code verification to detect bugs and security issues in AI-generated code using kluster.ai's specialized Verify.
---

# Code by Verify

Code is one of the features offered by [Verify](/verify/overview/){target=\_blank}, providing specialized tools to identify bugs in AI-generated code and verify the security of frameworks and libraries.

With Code verification, you can ship AI-generated code confidently, knowing potential issues are caught before they reach production.

The service works seamlessly with AI coding assistants in your IDE, analyzing code changes in real-time as they're generated.

## How Code works

The service evaluates AI-generated code by:

1. Analyzing the code changes in diff format.
2. Understanding the user's original request.
3. Detecting various types of issues (bugs, security vulnerabilities, performance problems).
4. Providing detailed explanations and actionable fixes.

The service evaluates code to identify issues, with the following fields:

- **`isCodeCorrect`**: Indicates whether the code has issues.
- **`issues`**: Array of detected problems with type, severity, and priority.
- **`explanation`**: Summary of all issues found.
- **`agent_todo_list`**: Prioritized list of fixes to apply.

## Configuration options

Code verification offers flexible configuration to match your development workflow:

- **Severity settings**: Configure minimum severity level for reporting (Low to Critical).
- **Bug check types**: Select which issue types to check: Semantic, Security, Quality, Intent, Knowledge, Logical, Performance.
- **Enabled tools**: Choose which MCP tools are active (bug check tool, packages check tool).

These settings can be configured directly in your IDE integration.

## When to use Code

The Code service is ideal for scenarios where you need:

- **AI code validation**: Verify AI-generated code before production use.
- **Security scanning**: Detect potential vulnerabilities in generated code.
- **Quality assurance**: Ensure code follows best practices.
- **Dependency checking**: Validate that new packages are secure and up-to-date.

## How to integrate Code

Code is currently available through MCP (Model Context Protocol) integrations:

<div class="grid cards" markdown>

-   <span class="badge guide">Guide</span> __Tools__

    ---

    Use Code verification tools directly in your IDE through MCP integration.

    [:octicons-arrow-right-24: View tools reference](/verify/code/tools/)

-   <span class="badge guide">Guide</span> __Integrations__

    ---

    Integrate Code verification with any MCP-compatible IDE, including Cursor and Claude code.

    [:octicons-arrow-right-24: Setup guide](/verify/code/integrations/)

</div>

## Additional resources

- **[Get started](/verify/code/quickstart/)**: Get Code verification running in minutes.
--- END CONTENT ---

Doc-Content: https://docs.kluster.aiverify/code/quickstart/
--- BEGIN CONTENT ---
---
title: Get started with Verify Code
description: Set up kluster.ai Code verification in minutes. Scan AI-generated code for errors, vulnerabilities, and performance issues with Cursor and AI assistants.
---

# Get started with Verify Code

Modern developers increasingly rely on AI coding assistants to accelerate development, but this speed comes with risks. Generated code may contain logic errors, security flaws, or performance issues that compromise application quality and security.

The [kluster.ai](https://www.kluster.ai/){target=\_blank} Code verification service integrates directly into your development workflow, automatically scanning AI-generated code in real-time. It catches potential issues instantly within your IDE, allowing you to ship code confidently while maintaining the speed benefits of AI-assisted development.

This guide will walk you through installing Code verification in Cursor.

## Get started in minutes

### One-click setup (recommended)

The fastest way to get started is with our one-click installation:

1. Install [Cursor](https://cursor.com/downloads){target=_blank} from their website if you don't have it yet.

2. Click [**Add to Cursor**](https://platform.kluster.ai/verify-code){target=_blank} to automatically install both the extension and MCP server.

![Quick start installation button for Code verification](/images/verify/code/quickstart/quickstart-1.webp)

This will automatically install Code Verify MCP server in Cursor for you.

!!! tip "Manual Setup"
    For manual setup instructions, please see our [integration guides](/verify/code/integrations/){target=\_blank}.

## Next steps

- [Learn about the tools](/verify/code/tools/) for detailed reference.
- [View integration guides](/verify/code/integrations/) for advanced setup.
--- END CONTENT ---

Doc-Content: https://docs.kluster.aiverify/code/tools/
--- BEGIN CONTENT ---
---
title: Code MCP Tools for Verify 
description: Learn how kluster.ai Code MCP tools work: parameters, response formats, issue categories, and settings for real-time code verification.
---

# Tools reference

The [kluster.ai](https://www.kluster.ai/){target=_blank} Code MCP server provides verification tools for checking AI-generated code quality and security. These tools enable real-time code verification directly within your IDE through MCP integration.

It includes:

- **`kluster_code_review_auto`**: Verifies code quality and detects bugs, including logic errors, security issues, and performance problems.
- **`kluster_dependency_validator`**: Validates the security and compliance of packages and dependencies in your code.

These tools share the same set of parameters. This page documents those parameters and the response formats you'll see when using these tools in Cursor, Claude Code, or any MCP-compatible client.

## Parameters

These tools analyze AI-generated code and its dependencies to detect bugs, security vulnerabilities, and other quality issues.

???+ interface "Parameters"

    `code_diff` ++"string"++ <span class="required" markdown>++"required"++</span>

    Unified diff format showing the actual code changes.

    ---

    `user_requests` ++"string"++ <span class="required" markdown>++"required"++</span>

    Chronological sequence of user messages with current request marked as `>>> CURRENT REQUEST:`.

    ---

    `modified_files_path` ++"string"++ <span class="required" markdown>++"required"++</span>

    Full absolute paths of modified files separated by `;`.

## Response fields

All Code verification tools return the same response structure:

- **`isCodeCorrect`**: Boolean indicating if the code has issues.
- **`explanation`**: Summary of all issues found.
- **`issues`**: Array of detected problems with:
  - **`type`**: Issue category (intent, semantic, knowledge, performance, quality, logical, security).
  - **`severity`**: Impact level (critical, high, medium, low).
  - **`priority`**: Execution priority (P0-P5).
  - **`description`**: Brief issue summary.
  - **`explanation`**: Detailed issue explanation.
  - **`actions`**: Recommended fixes.
- **`priority_instructions`**: Execution rules for addressing issues.
- **`agent_todo_list`**: Prioritized list of fixes to apply.

### Example response

```json
{  
    "isCodeCorrect": false,  
    "explanation": "Found 3 issues. 1 critical issue needs immediate attention.",  
    "issues": [  
        {  
            "type": "security",  
            "severity": "critical",  
            "priority": "P2",  
            "description": "SQL injection vulnerability",  
            "explanation": "User input is directly concatenated into SQL query without sanitization.",  
            "actions": "Use parameterized queries or prepared statements."  
        }  
    ],  
    "priority_instructions": "Fix P2 issues before deploying code.",  
    "agent_todo_list": [  
        "P2.1: Fix SQL injection vulnerability by using parameterized queries"  
    ]  
}
```

## Bug check types

Code verification categorizes detected issues into seven distinct types, each targeting specific aspects of code quality and correctness. You have full control over which bug types to check for through simple on/off toggles.

|     Type      |           Description           |                Example                |
|:-------------:|:-------------------------------:|:-------------------------------------:|
|   `intent`    | Code doesn't match user request | User asked for sorting, got filtering |
|  `semantic`   |          Logic errors           |        Missing error handling         |
|  `knowledge`  |    Best practice violations     |       Not following conventions       |
| `performance` |       Performance issues        |        Inefficient algorithms         |
|   `quality`   |      Code quality problems      |        Poor naming, complexity        |
|   `logical`   |          Logic errors           |           Off-by-one errors           |
|  `security`   |    Security vulnerabilities     |          SQL injection risks          |

## Priority system

Code verification assigns priority levels to detected issues, helping you focus on the most critical problems first. The system automatically prioritizes based on issue type and severity.

- **P0-P1**: Intent issues (highest priority) - code doesn't match request.
- **P2**: Critical severity - must fix immediately.
- **P3**: High severity - should fix soon.
- **P4**: Medium severity - nice to fix.
- **P5**: Low severity - optional improvements.

## Configuration settings

You can customize the Code verification behavior through the settings page in your IDE. This allows you to tailor the verification process to your specific needs, such as configuring severity levels for issue reporting, selecting which types of bug checks to perform, and enabling or disabling specific MCP tools to match your development workflow.

![Screenshot of Code verification settings interface showing severity levels and enabled tools configuration options.](/images/verify/code/tools/tools-1.webp)

### Severity settings

Configure the minimum severity level for issue reporting. Set your threshold based on your team's needs: **Low**, **Medium**, **High**, **Critical**.

The ideal setting depends on your use case. For example, a **High** level is a good starting point, but you might want to set it to **Medium** for production code.

### Enabled tools

Choose which MCP tools are active:

- **Bug Check Tool**: For code quality verification.
- **Packages Check Tool**: For dependency security.

## Next steps

- **[Set up integrations](/verify/code/integrations/)**: Configure IDE integrations to use these tools.
- **[Get started](/verify/code/quickstart/)**: Follow the quickstart guide for immediate setup.
--- END CONTENT ---

Doc-Content: https://docs.kluster.aiverify/get-api-key/
--- BEGIN CONTENT ---
---
title: Get a kluster.ai API key
description: Follow step-by-step instructions to generate and manage API keys, enabling secure access to kluster's services and seamless integration with your applications.
---

# Generate your kluster.ai API key

The API key is a unique identifier that authenticates requests associated with your account. You must have at least one API key to access [kluster.ai](https://www.kluster.ai/){target=\_blank}'s services.

This guide will help you obtain an API key, the first step to leveraging kluster.ai's powerful and cost-effective AI capabilities.

## Create an account

If you haven't already created an account with kluster.ai, visit the [registration page](https://platform.kluster.ai/signup){target=\_blank} and take the following steps:

1. Enter your full name.
2. Provide a valid email address.
3. Create a secure password.
4. Click the **Sign up** button.

![Signup Page](/images/get-api-key/get-api-key-1.webp)

## Generate a new API key

After you've signed up or logged into the platform through the [login page](https://platform.kluster.ai/login){target=\_blank}, take the following steps:

1. Select **API Keys** on the left-hand side menu.
2. In the [**API Keys**](https://platform.kluster.ai/apikeys){target=\_blank} section, click the **Issue New API Key** button.

    ![Issue New API Key](/images/get-api-key/get-api-key-2.webp)

3. Enter a descriptive name for your API key in the popup, then click **Create Key**.

    ![Generate API Key](/images/get-api-key/get-api-key-3.webp)

## Copy and secure your API key

1. Once generated, your API key will be displayed.
2. Copy the key and store it in a secure location, such as a password manager.

    !!! warning "Warning"
        For security reasons, you won't be able to view the key again. If lost, you will need to generate a new one.

![Copy API key](/images/get-api-key/get-api-key-4.webp)

!!! abstract "Security tips"
    - **Keep it secret**: Do not share your API key publicly or commit it to version control systems.
    - **Use environment variables**: Store your API key in environment variables instead of hardcoding them.
    - **Regenerate if compromised**: If you suspect your API key has been exposed, regenerate it immediately from the **API Keys** section.

## Manage your API keys

The **API Key Management** section allows you to efficiently manage your kluster.ai API keys. You can create, view, and delete API keys by navigating to the [**API Keys**](https://platform.kluster.ai/apikeys){target=\_blank} section. Your API keys will be listed in the **API Key Management** section.

To delete an API key, take the following steps:

1. Locate the API key you wish to delete in the list.
2. Click the trash bin icon ( :octicons-trash-24: ) in the **Actions** column.
3. Confirm the deletion when prompted.

![Delete API key](/images/get-api-key/get-api-key-5.webp)

!!! warning "Warning"
    Once deleted, the API key cannot be used again and you must generate a new one if needed.

## Next steps

Now that you have your API key, you can start integrating kluster.ai's Verify services into your applications. Refer to our [Getting Started](/verify/code/quickstart/) guide for detailed instructions on using the API.
--- END CONTENT ---

Doc-Content: https://docs.kluster.aiverify/mcp/client-integrations/
--- BEGIN CONTENT ---
---
title: MCP client integrations
description: Connect Claude desktop, VS Code, Cursor, and Claude Code to kluster.ai verification tools with ready-to-use configuration examples.
---

# Client integrations

Connect any compatible client to [kluster.ai's](https://www.kluster.ai/){target=\_blank} MCP Verify server. This guide provides configuration examples for popular clients using [Cloud MCP](/verify/mcp/cloud/platform/).

!!! info "Self-hosted deployment"
    For [self-hosted MCP](/verify/mcp/self-hosted/){target=\_blank}, replace the URL with `http://localhost:3001/stream` and use your kluster.ai API key.

## Prerequisites
      
Before integrating with any client, ensure you have the required credentials:
      
-- **A kluster.ai account**: Sign up on the [kluster.ai platform](https://platform.kluster.ai/signup){target=\_blank} if you don't have one.
- **A kluster.ai API key**: After signing in, go to the [**API Keys**](https://platform.kluster.ai/apikeys){target=\_blank} section and create a new key. For detailed instructions, check out the [Get an API key](/verify/get-api-key/){target=\_blank} guide.
- **MCP token** (for some clients): Follow the [platform guide](/verify/mcp/cloud/platform/){target=\_blank} to enable MCP and obtain your token.

!!! info "Which credential do I need?"
    Depending on the client and configuration method, you may need either your kluster.ai API key or your MCP token. Each configuration section below specifies which credential to use.

## Configuration by client

=== "Claude desktop (.dxt file)"

    The easiest way to add kluster Verify to Claude desktop is using the `.dxt` extension file:

    1. **Download the extension**: [kluster-verify-mcp.dxt](/verify/mcp/resources/kluster-verify-mcp.dxt)

    2. **Install the Verify MCP**: Go to the **Extensions** tab in the settings menu and drag and drop the `.dxt` file, then click **Install**.

        ![](/images/verify/mcp/integrations/integrations-3.webp){ style="width:80%;" }

    3. **Add your API key**: When prompted, enter your kluster.ai API key (follow the [Get an API key guide](/verify/get-api-key/){target=\_blank} to obtain one).

        ![](/images/verify/mcp/integrations/integrations-4.webp){ style="width:80%;" }

    4. **Enable the extension and start using**: The kluster Verify tools will be available immediately in your conversations.

        ![](/images/verify/mcp/integrations/integrations-5.webp){ style="width:80%;" }

=== "Claude desktop (JSON config)"

    If you prefer manual configuration, you can add kluster Verify by editing Claude desktop's configuration file:

    1. Locate the configuration file:
        - **macOS**: `~/Library/Application Support/Claude/claude_desktop_config.json`
        - **Windows**: `%APPDATA%/Claude/claude_desktop_config.json`

    2. Add the MCP server configuration:
    
        ```json
        -{
    "mcpServers": {
        "kluster-verify-mcp": {
            "command": "npx",
            "args": [
                "mcp-remote",
                "https://api.kluster.ai/v1/mcp",
                "--header",
                "Authorization: Bearer YOUR_MCP_TOKEN"
            ]
        }
    }
}
        ```

    3. Replace `YOUR_MCP_TOKEN` with your actual MCP token (obtained after [enabling MCP](/verify/mcp/cloud/platform/){target=\_blank}) on the kluster.ai platform.

    4. Save the file and restart Claude desktop to load the kluster Verify tools.

        ![](/images/verify/mcp/get-started/get-started-1.webp){ style="width:80%;" }

=== "VS Code"

    1. Install [GitHub Copilot](https://marketplace.visualstudio.com/items?itemName=GitHub.copilot){target=\_blank} extension.
    2. Open the Chat view and click on the tools icon.

        ![](/images/verify/mcp/integrations/integrations-1.webp){ style="width:50%;" }

    3. Choose **Add More Tools...** and click on **Add MCP Server...**.
    4. Select **Command (stdio)** and enter the following command, replacing `YOUR_MCP_TOKEN` with your actual MCP token:

        ```bash
        npx mcp-remote https://api.kluster.ai/v1/mcp \
        --header "Authorization: Bearer YOUR_MCP_TOKEN"
        ```

    5. Restart VS Code.

=== "Cursor"

    Open Cursor settings and:
    
    1. Select **Tools & Integrations**.

    2. To add your first MCP, click **Add Custom MCP**. To add additional MCPs later, use **New MCP Server**. Then enter the following configuration:
            
        ```json
        {
            "mcpServers": {
                "kluster-verify-mcp": {
                    "url": "https://api.kluster.ai/v1/mcp",
                    "headers": {
                        "Authorization": "Bearer YOUR_MCP_TOKEN"
                    }
                }
            }
        }
        ```

    3. Restart Cursor.

    ![](/images/verify/mcp/integrations/integrations-2.webp){ style="width:80%;" }

=== "Claude code"

    Run this command in your terminal:

    ```bash
    claude mcp add kluster-verify-mcp \
      npx mcp-remote https://api.kluster.ai/v1/mcp \
      --header "Authorization: Bearer YOUR_MCP_TOKEN"
    ```

## Available tools

-- **`verify`**: Validates prompt and response pairs against reliable sources.
- **`verify_document`**: Verifies prompt and response pairs in relation to uploaded documents.




## SDK integrations

Looking to integrate MCP tools into your own applications? Check out the SDK integration guides:

- **[OpenAI Agents SDK](/verify/mcp/sdk-integrations/openai-agents/)**: Build Python agents with built-in verification capabilities using OpenAI's Agents framework.

## Next steps

- [Complete setup guide](/verify/mcp/get-started/) with usage examples.
- [Self-hosted deployment](/verify/mcp/self-hosted/) for local development.
--- END CONTENT ---

Doc-Content: https://docs.kluster.aiverify/mcp/cloud/ap/
--- BEGIN CONTENT ---
---
title: Cloud MCP API usage
description: Complete guide to using kluster.ai's Cloud MCP API with JSON-RPC requests. How to check it's status, enable, disable and test it. 
---

# API usage

Manage your Cloud MCP endpoint using API calls. This guide covers checking status, enabling and disabling your endpoint, obtaining MCP tokens, and testing verification tools. Use this as an alternative to the [platform UI](/verify/mcp/cloud/platform/){target=\_blank}.

## Prerequisites

Before getting started with MCP via API, ensure you have:

-- **A kluster.ai account**: Sign up on the [kluster.ai platform](https://platform.kluster.ai/signup){target=\_blank} if you don't have one.
- **A kluster.ai API key**: After signing in, go to the [**API Keys**](https://platform.kluster.ai/apikeys){target=\_blank} section and create a new key. For detailed instructions, check out the [Get an API key](/verify/get-api-key/){target=\_blank} guide.

## Manage your MCP endpoint

### Check status

First, check if your MCP endpoint is already enabled:

```bash
curl -X GET https://api.kluster.ai/v1/mcp/status \
  -H "Authorization: Bearer YOUR_API_KEY"
```

If disabled, the response shows:

```json
{
    "enabled": false,
    "url": "",
    "apiKey": ""
}
```

### Enable endpoint

If not enabled, activate your MCP endpoint:

```bash
curl -X POST https://api.kluster.ai/v1/mcp/enable \
  -H "Authorization: Bearer YOUR_API_KEY"
```

The response includes your MCP token:

```json
{
    "enabled": true,
    "url": "https://api.kluster.ai/v1/mcp",
    "token": "MCP_TOKENxxxxxxxxxxxx"
}
```

Your MCP token is a specialized authentication token used specifically for MCP verification calls, separate from your main API key. Use this token when using all MCP verification tools.

!!! warning "Store your token securely"
    Store the token securely, as it provides access to your MCP verification services.
        
### Disable endpoint (optional)

You may want to disable your MCP endpoint. This option prevents any further MCP calls using that token until you enable the endpoint again.

To revoke access:

```bash
curl -X POST https://api.kluster.ai/v1/mcp/disable \
  -H "Authorization: Bearer YOUR_API_KEY"
```

## API overview

Cloud MCP uses JSON-RPC 2.0 with streaming support:

- **Management endpoints**: Use your main API key with `Authorization: Bearer YOUR_API_KEY`.
- **MCP endpoint**: `https://api.kluster.ai/v1/mcp`.
- **Method**: `POST`.
- **Authentication**: `Authorization: Bearer YOUR_MCP_TOKEN` (uses the MCP token from enable response).
- **Content-Type**: `application/json`.
- **Accept**: `application/json, text/event-stream` (required for streaming support).

## Request structure

All requests use the MCP tools/call format:

```json
{
    "jsonrpc": "2.0",
    "method": "tools/call",
    "params": {
        "name": "tool_name",
        "arguments": {
            // Tool-specific parameters
        }
    },
    "id": 1
}
```

## Test MCP tools

The following request is an example using the `verify` tool:

```bash
curl -X POST https://api.kluster.ai/v1/mcp \
  -H "Authorization: Bearer YOUR_MCP_TOKEN" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json, text/event-stream" \
  -d '{
      "jsonrpc": "2.0",
      "method": "tools/call",
      "params": {
          "name": "verify",
          "arguments": {
              "prompt": "Is the Great Wall of China visible from space?",
              "response": "Yes, the Great Wall of China is visible from space with the naked eye."
          }
      },
      "id": 1
  }'
```

The response includes verification results nested in JSON-RPC format. 

## Next steps

- [Client integrations](/verify/mcp/client-integrations/) to configure your AI clients.
--- END CONTENT ---

Doc-Content: https://docs.kluster.aiverify/mcp/cloud/platform/
--- BEGIN CONTENT ---
---
title: Cloud MCP platform management
description: Enable and manage kluster.ai's Cloud MCP endpoints through the platform UI with one-click setup and visual client examples.
---

# Platform management

Manage your Cloud MCP endpoint directly through the [kluster.ai platform](https://platform.kluster.ai){target=\_blank} interface. Enable your MCP, view your credentials, and access ready-to-use client examples.

This guide shows how to enable MCP through the platform UI and quickly integrate verification tools into your applications.

## Prerequisites

-- **A kluster.ai account**: Sign up on the [kluster.ai platform](https://platform.kluster.ai/signup){target=\_blank} if you don't have one.
- **A kluster.ai API key**: After signing in, go to the [**API Keys**](https://platform.kluster.ai/apikeys){target=\_blank} section and create a new key. For detailed instructions, check out the [Get an API key](/verify/get-api-key/){target=\_blank} guide.

- **A kluster.ai account**: Sign up on the [kluster.ai platform](https://platform.kluster.ai/signup){target=\_blank} if you don't have one.

## Enable and use the MCP endpoint

To enable the MCP endpoint, go to the [kluster.ai platform](https://platform.kluster.ai){target=\_blank}

1. Navigate to **MCP** and view your current MCP status.
2. Click the **Enable Verify MCP** button to activate your endpoint.
3. Copy your client configuration.

Your MCP endpoint is now active. Copy your API key and save it securely. The platform provides ready-to-use integration examples for VSCode, Cursor, Claude code, and Claude desktop.

![MCP kluster.ai platform](/images/verify/mcp/cloud/platform/platform-1.webp)

## Next steps

- **Explore the API**: Learn about [API usage and integration patterns](/verify/mcp/cloud/api/).
- **Check pricing**: Review [MCP usage pricing](https://kluster.ai/pricing){target=\_blank}.
--- END CONTENT ---

Doc-Content: https://docs.kluster.aiverify/mcp/get-start/
--- BEGIN CONTENT ---
---
title: Get started with MCP
description: Get kluster.ai verification tools integrated into Claude desktop in five minutes using Cloud MCP. No setup required, just enable and connect.
---

# Get started with MCP

Connect [kluster.ai's](https://www.kluster.ai/){target=\_blank} verification tools to your AI assistant through Model Context Protocol (MCP). This guide shows you how to enable [Cloud MCP](/verify/mcp/cloud/platform/) and integrate it with Claude desktop for real-time claim validation directly within your conversations.

Cloud MCP provides managed verification endpoints with no infrastructure to maintain - just enable your MCP endpoint and start verifying.

## Prerequisites

Before getting started, ensure you have:

-- **A kluster.ai account**: Sign up on the [kluster.ai platform](https://platform.kluster.ai/signup){target=\_blank} if you don't have one.
- **A kluster.ai API key**: After signing in, go to the [**API Keys**](https://platform.kluster.ai/apikeys){target=\_blank} section and create a new key. For detailed instructions, check out the [Get an API key](/verify/get-api-key/){target=\_blank} guide.
- **[Claude desktop](https://claude.ai/download){target=\_blank}** for testing the integration.

## Enable MCP 

To enable the MCP endpoint, go to the [kluster.ai platform](https://platform.kluster.ai){target=\_blank} and take the following steps:

1. Navigate to **MCP** and view your current MCP status.
2. Click the **Enable Verify MCP** button to activate your endpoint.
3. Copy your client configuration.

!!! success "Endpoint enabled"
    Your MCP endpoint is now active. Copy your API key and save it securely.
    
The platform provides ready-to-use integration examples for VSCode, Cursor, Claude code, and Claude desktop.

![MCP kluster.ai platform](/images/verify/mcp/cloud/platform/platform-1.webp)

## Configure Claude desktop

Edit your Claude desktop configuration file:

=== "macOS"

    ```text
    ~/Library/Application Support/Claude/claude_desktop_config.json
    ```

=== "Windows"

    ```text
    %APPDATA%/Claude/claude_desktop_config.json
    ```

Add the MCP server configuration:

```json
-{
    "mcpServers": {
        "kluster-verify-mcp": {
            "command": "npx",
            "args": [
                "mcp-remote",
                "https://api.kluster.ai/v1/mcp",
                "--header",
                "Authorization: Bearer YOUR_MCP_TOKEN"
            ]
        }
    }
}
```

Replace `YOUR_MCP_TOKEN` with your actual token or copy the snippet from the platform.

Restart Claude desktop. Once Claude desktop restarts, you'll see the verification tools available under `kluster-verify-mcp`.

![List tools on Claude desktop](/images/verify/mcp/get-started/get-started-1.webp)

## Available tools

Your MCP integration provides two verification tools:

-- **`verify`**: Validates prompt and response pairs against reliable sources.
- **`verify_document`**: Verifies prompt and response pairs in relation to uploaded documents.



### Verify

Ask Claude to verify something obviously wrong:

> "The Eiffel Tower is located in Rome. Use the verify tool to check this."

Claude will automatically use the `verify` tool with:

- **`prompt`**: "Is the Eiffel Tower located in Rome?"
- **`response`**: "The Eiffel Tower is located in Rome."

And provides the following:

- **Verification result**: Whether the response contains hallucinations.
- **Detailed explanation**: Why it's wrong with supporting reasoning.
- **Source citations**: Search results used for verification.

![Verify MCP tool demo](/images/verify/mcp/get-started/get-started-2.webp)

### Verify documents

Perfect for detecting hallucinations or false claims about documents. Upload any document to Claude, then ask:

> "Does this document say that employees can work remotely full-time? The document says employees can work remotely without restrictions. Use the verify_document tool to check."

Claude will use the `verify_document` tool with:

- **`prompt`**: "Does this document say that employees can work remotely full-time?"
- **`response`**: "The document says employees can work remotely without restrictions."
- **`documentContent`**:  The content of the document as provided by the MCP client for verification.

This verifies the response against the actual document content.

## Alternative setup options

- **Other clients**: Want to use VS Code, Cursor, or Claude Code? Check the [Client integrations](/verify/mcp/client-integrations/){target=\_blank} guide for configuration examples.

- **Self-hosted**: Prefer to run MCP locally? Set up the [self-hosted MCP server](/verify/mcp/self-hosted/){target=\_blank} for local development with full control.

- **API activation**: Enable MCP using API calls with the [MCP API usage guide](/verify/mcp/cloud/api/){target=\_blank}.

## Next steps

- **Explore integrations**: Check [Client integrations](/verify/mcp/client-integrations/) for other platforms.
--- END CONTENT ---

Doc-Content: https://docs.kluster.aiverify/mcp/overview/
--- BEGIN CONTENT ---
---
title: MCP integration overview
description: Connect AI apps to kluster.ai services using MCP for seamless development workflow integration with verification tools and automated reliability checking.
---

# MCP integration

[Model Context Protocol](https://modelcontextprotocol.io/introduction){target=\_blank} (MCP) is an open standard for connecting AI assistants to specialized tools. Think of it as "USB-C for AI" - one protocol that works everywhere, enabling seamless integration between AI applications and external capabilities.

[kluster.ai](https://www.kluster.ai/){target=\_blank} provides MCP servers that bring AI services directly into your development workflow. Choose between a managed cloud endpoint or self-hosted deployment for seamless integration across platforms.

## What is MCP?

MCP lets AI applications access external capabilities:

- **Local tools**: Files, databases, custom functions.
- **Remote services**: APIs, web services, cloud resources.
- **Specialized features**: Like kluster.ai's verification technology.

## MCP through kluster.ai services

Instead of managing API calls and integrations, access kluster.ai's AI capabilities as native tools in Claude desktop, VS Code, and other MCP-compatible platforms.

The kluster.ai MCP offers the [Verify service](/verify/reliability/overview){target=\_blank} through two deployment options designed for different use cases and platforms.

### Cloud MCP

Managed cloud implementation - no infrastructure to maintain:

-- **`verify`**: Validates prompt and response pairs against reliable sources.
- **`verify_document`**: Verifies prompt and response pairs in relation to uploaded documents.


Enable your endpoint through the kluster.ai platform, get your MCP token, and start verifying. Works with any MCP client using standard connection patterns.

### Self-hosted MCP

Same verification tools running on your infrastructure with full control. Deploy locally with Docker or Node.js.

## Integrate MCP

<div class="grid cards" markdown>

-   <span class="badge guide">Guide</span> __Get started with MCP__

    ---

    Quick start guide using Cloud MCP as the default path. Enable your endpoint and connect Claude Desktop in five minutes.

    [:octicons-arrow-right-24: Five-minute setup](/verify/mcp/get-started/){target=_self}

-   <span class="badge guide">Guide</span> __Cloud MCP__

    ---

    Enable managed MCP endpoints with MCP token authentication. There is no infrastructure to maintain, just enable and integrate.

    [:octicons-arrow-right-24: Platform setup](/verify/mcp/cloud/platform/){target=_self}

-   <span class="badge guide">Guide</span> __Self-hosted MCP__

    ---

    Deploy the MCP server locally with Docker or Node.js. Perfect for development and testing with full control.

    [:octicons-arrow-right-24: Local deployment](/verify/mcp/self-hosted/){target=_self}

</div>

## Additional resources

- **MCP protocol**: [Official MCP documentation](https://modelcontextprotocol.io/docs){target=\_blank}.
- **Verify service**: [Complete reliability verification guide](/verify/reliability/overview).
--- END CONTENT ---

Doc-Content: https://docs.kluster.aiverify/mcp/sdk-integrations/openai-agents/
--- BEGIN CONTENT ---
---
title: Integrate OpenAI Agents SDK with kluster Verify
description: Integrate OpenAI Agents SDK with kluster Verify to create AI agents that detect hallucinations and validate facts with real-time verification.
---

# Integrate OpenAI Agents SDK with kluster Verify

[OpenAI Agents SDK](https://openai.github.io/openai-agents-python/){target=_blank} provides a powerful framework for building AI agents that can use tools, maintain context, and interact with external services. By integrating with [kluster Verify](/verify/overview/){target=_blank}, you can create agents that not only generate responses using [kluster.ai's](https://www.kluster.ai/){target=_blank} language models but also perform real-time reliability verification to detect hallucinations and validate factual claims with internet-sourced verification.

This guide demonstrates how to integrate the `Agent` and `Runner` classes from the OpenAI Agents SDK with kluster.ai's API and MCP server, and then walks through building an interactive chatbot that utilizes kluster Verify's hallucination detection capabilities.

## Prerequisites

-- **A kluster.ai account**: Sign up on the [kluster.ai platform](https://platform.kluster.ai/signup){target=\_blank} if you don't have one.
- **A kluster.ai API key**: After signing in, go to the [**API Keys**](https://platform.kluster.ai/apikeys){target=\_blank} section and create a new key. For detailed instructions, check out the [Get an API key](/verify/get-api-key/){target=\_blank} guide.
- **Python 3.9+**: Make sure pip is also installed.
- **[A Python virtual environment](https://packaging.python.org/en/latest/guides/installing-using-pip-and-virtual-environments/){target=_blank}**: This is optional but recommended. Ensure that you enter the Python virtual environment before following along with this tutorial.
- **OpenAI Agents SDK packages installed**: Use the following command to install the [`openai-agents` packages](https://github.com/openai/openai-agents-python){target=_blank}.

    ```bash
    pip install "openai>=1.93.0" "openai-agents>=0.1.0" "mcp[cli]>=1.10.1"
    ```

- **MCP enabled**: This can be done via the [platform](https://platform.kluster.ai){target=_blank} or the [API](/verify/mcp/cloud/api/){target=\_blank}.

## Quick start

It's easy to integrate kluster Verify with OpenAI Agents SDK—when configuring the agent, point your `AsyncOpenAI` instance to the correct base URL and configure the following settings:

  - **Base URL**: Use `https://api.kluster.ai/v1` to send requests to the kluster.ai endpoint.
  - **API key**: Replace with your kluster.ai API key. If you don't have one yet, refer to the [Get an API key guide](/verify/get-api-key/).
  - **Select your model**: Choose a model with tool support from [kluster.ai's models](https://platform.kluster.ai/models){target=_blank} (filter by **Tool Support**).
  - **MCP server**: Configure the MCP server URL and token for kluster Verify's Reliability service.

```python
from agents import (
    Agent, 
    Runner, 
    set_tracing_disabled, 
    set_default_openai_api, 
    OpenAIChatCompletionsModel
)
from agents.mcp.server import MCPServerStreamableHttp
from openai import AsyncOpenAI
import asyncio
import getpass

# Configure SDK for production use
set_tracing_disabled(True)  # Disable OpenAI telemetry
set_default_openai_api("chat_completions")  # Use stable Chat API

# Get credentials securely
api_key = getpass.getpass("Enter your kluster.ai API key: ")
mcp_token = getpass.getpass("Enter your MCP token: ")

# Create kluster.ai client
kluster_client = AsyncOpenAI(
    base_url="https://api.kluster.ai/v1",
    api_key=api_key
)

# Configure MCP server for verification
mcp_server = MCPServerStreamableHttp(
    params={
        "url": "https://api.kluster.ai/v1/mcp",
        "headers": {"Authorization": f"Bearer {mcp_token}"},
        "timeout": 15,
        "sse_read_timeout": 15
    },
    client_session_timeout_seconds=30  # Increase from default 5 seconds to 30 seconds
)

# Create agent with kluster Verify capabilities
agent = Agent(
    name="ReliableAgent",
    instructions="Use kluster Verify for factual claims. Verify can detect hallucinations and validate information against real-time sources.",
    model=OpenAIChatCompletionsModel(
        model="deepseek-ai/DeepSeek-V3-0324",
        openai_client=kluster_client
    ),
    mcp_servers=[mcp_server]
)

# Run the agent
async def main():
    await mcp_server.connect()
    result = await Runner.run(agent, "Is the Earth flat?")
    print(result.final_output)

asyncio.run(main())
```

That's all you need to start with OpenAI Agents SDK and kluster Verify! Next, this guide will explore building an interactive chatbot that showcases kluster Verify's hallucination detection and real-time verification capabilities.

Only models with tool support can use MCP verification. To find compatible options, filter by **Tool Support** on the [platform models page](https://platform.kluster.ai/models){target=_blank}.

For self-hosted MCP, use `http://localhost:3001/stream` along with the kluster.ai API key.

!!! warning "Known async cleanup issue"
    Error messages about "Exception ignored in atexit callback" may appear when the script exits. This is a [known issue](https://github.com/modelcontextprotocol/python-sdk/issues/521){target=_blank} with MCP's asyncio cleanup that **does not affect functionality**. The script will work correctly despite these messages.

## Enable MCP

If you prefer, you can enable MCP and obtain your token via API calls instead of using the platform interface. This approach allows you to automate the token retrieval process and integrate it directly into your application setup workflow.

```python
import requests

# Enable MCP
response = requests.post(
    "https://api.kluster.ai/v1/mcp/enable",
    headers={"Authorization": f"Bearer {api_key}"}
)

# Get status with token
status = requests.get(
    "https://api.kluster.ai/v1/mcp/status", 
    headers={"Authorization": f"Bearer {api_key}"}
)
mcp_token = status.json()["apiKey"]
```

## Build an interactive chatbot

This example creates an interactive chatbot where you can ask questions and see kluster Verify validate the responses in real-time, demonstrating how verification enhances conversational AI.

Unlike the previous single-query example, this implementation creates a persistent conversational experience that continues until the user chooses to exit. Each interaction goes through the full verification pipeline, meaning every response is automatically checked for accuracy and potential hallucinations before being presented to the user.

```python
from agents import (
    Agent, 
    Runner, 
    set_tracing_disabled, 
    set_default_openai_api, 
    OpenAIChatCompletionsModel
)
from agents.mcp.server import MCPServerStreamableHttp
from openai import AsyncOpenAI
import asyncio
import getpass

# Configure SDK
set_tracing_disabled(True)
set_default_openai_api("chat_completions")

# Get credentials
api_key = getpass.getpass("Enter your kluster.ai API key: ")
mcp_token = getpass.getpass("Enter your MCP token: ")

# Create kluster.ai client
kluster_client = AsyncOpenAI(
    base_url="https://api.kluster.ai/v1",
    api_key=api_key
)
# Create MCP server
mcp_server = MCPServerStreamableHttp(
    params={
        "url": "https://api.kluster.ai/v1/mcp",
        "headers": {"Authorization": f"Bearer {mcp_token}"},
        "timeout": 15,
        "sse_read_timeout": 15
    },
    client_session_timeout_seconds=30  # Increase from default 5 seconds to 30 seconds
)

# Create chatbot agent
agent = Agent(
    name="VerifyChatbot",
    instructions="Use kluster Verify to validate factual claims and provide reliable responses.",
    model=OpenAIChatCompletionsModel(
        model="deepseek-ai/DeepSeek-V3-0324",
        openai_client=kluster_client
    ),
    mcp_servers=[mcp_server]
)

# Interactive chat loop
async def main():
    await mcp_server.connect()
    
    print("🤖 Chatbot ready! Type 'quit' to exit.")
    
    while True:
        user_input = input("\n👤 You: ").strip()
        
        if user_input.lower() in ['quit', 'exit', 'q']:
            print("👋 Goodbye!")
            break
            
        if user_input:
            result = await Runner.run(agent, user_input)
            print(f"🤖 Bot: {result.final_output}")

asyncio.run(main())
```

??? code "Complete example"

    This complete example demonstrates how OpenAI Agents can leverage kluster Verify's hallucination detection through the MCP protocol.

    ```python
    import asyncio
    import requests
    import getpass
    from agents import (
        Agent, 
        Runner, 
        set_tracing_disabled, 
        set_default_openai_api, 
        OpenAIChatCompletionsModel
    )
    from agents.mcp.server import MCPServerStreamableHttp
    from openai import AsyncOpenAI

    def setup_mcp_token():
        """Enable MCP and get token"""
        api_key = getpass.getpass("Enter your kluster.ai API key: ")
        headers = {"Authorization": f"Bearer {api_key}"}
        
        # Enable MCP
        requests.post("https://api.kluster.ai/v1/mcp/enable", headers=headers)
        
        # Get token
        response = requests.get("https://api.kluster.ai/v1/mcp/status", headers=headers)
        return api_key, response.json()["apiKey"]

    async def main():
        set_tracing_disabled(True)
        set_default_openai_api("chat_completions")
        
        api_key, mcp_token = setup_mcp_token()
        
        # Create kluster.ai client
        kluster_client = AsyncOpenAI(
            base_url="https://api.kluster.ai/v1",
            api_key=api_key
        )
        

        # Create MCP server
        mcp_server = MCPServerStreamableHttp(
            params={
                "url": "https://api.kluster.ai/v1/mcp",
                "headers": {"Authorization": f"Bearer {mcp_token}"},
                "timeout": 15,
                "sse_read_timeout": 15
            },
            client_session_timeout_seconds=30  # Increase from default 5 seconds to 30 seconds
        )
        
        # Create agent
        agent = Agent(
            name="KlusterVerifyAgent",
            instructions="""You are a helpful assistant. Answer questions directly and accurately. 

    IMPORTANT: Always use kluster Verify's Reliability for factual claims.
    When verification shows is_hallucination=true, acknowledge the correction.

    Include Verify's explanations and search results when provided.""",
            model=OpenAIChatCompletionsModel(
                model="deepseek-ai/DeepSeek-V3-0324",
                openai_client=kluster_client
            ),
            mcp_servers=[mcp_server]
        )
        
        await mcp_server.connect()
        
        print("\n✅ Chatbot ready! Type 'quit' to exit.")
        print("💬 Ask me anything and I'll verify my responses:\n")
        
        while True:
            try:
                # Get user input
                user_input = input("👤 You: ").strip()
                
                if user_input.lower() in ['quit', 'exit', 'q']:
                    print("\n👋 Goodbye!")
                    break
                    
                if not user_input:
                    continue
                
                # Get agent response with verification
                print("🤖 Bot: Thinking and verifying...")
                result = await Runner.run(agent, user_input)
                print(f"🤖 Bot: {result.final_output}\n")
                
            except KeyboardInterrupt:
                print("\n\n👋 Goodbye!")
                break
            except Exception as e:
                print(f"❌ Error: {e}\n")

    if __name__ == "__main__":
        asyncio.run(main())
    ```

## Run the script


1. Use the following command to run the script:

    ```bash
    python reliable_agent.py
    ```

2. Enter your kluster.ai API key when prompted. If you don't have one yet, refer to the [Get an API key guide](/verify/get-api-key/){target=\_blank}.

Expected output:

<div class="termynal" data-termynal>
    <span data-ty="input">python reliable_agent.py</span>
    <span data-ty="input">🔑 Enter your kluster.ai API Key: ••••••••••••••••</span>
    <span data-ty>✅ Chatbot ready! Type 'quit' to exit.</span>
    <span data-ty>💬 Ask me anything and I'll verify my responses:</span>
    <span data-ty></span>
    <span data-ty="input">👤 You: Is it true that the Eiffel Tower was moved to London in May 2025?</span>
    <span data-ty>🤖 Bot: Thinking and verifying...</span>
    <span data-ty>🤖 Bot: No, the Eiffel Tower was not moved to London in May 2025 or at any other time. It remains in its original location in Paris, France.</span>
    <span data-ty></span>
    <span data-ty>### Verification Details:</span>
    <span data-ty>- **Explanation**: The search results confirm that the Eiffel Tower is located in Paris, and there is no credible information suggesting it was relocated to London.</span>
    <span data-ty>- **Supporting Sources**:</span>
    <span data-ty>  - [Eiffel Tower - Wikipedia](https://en.wikipedia.org/wiki/Eiffel_Tower) describes its location as Paris, France.</span>
    <span data-ty>  - Other sources mention proposals or ideas for towers in London but confirm these are unrelated to the Eiffel Tower.</span>
    <span data-ty></span>
    <span data-ty>The claim about the Eiffel Tower being moved to London is false.</span>
    <span data-ty></span>
    <span data-ty></span>
    <span data-ty="input">👤 You: quit</span>
    <span data-ty></span>
    <span data-ty>👋 Goodbye!</span>
</div>

That's it! You've successfully integrated OpenAI Agents SDK with kluster Verify, and your configured agent is ready to leverage real-time hallucination detection and Reliability. For more information about the capabilities of OpenAI Agents SDK, be sure to check out the [OpenAI Agents docs](https://openai.github.io/openai-agents-python/){target=_blank}.

## Next steps

- Explore [kluster Verify's Reliability](/verify/reliability/overview/) for all verification capabilities.
- Learn about [tool filtering](https://openai.github.io/openai-agents-python/mcp/#tool-filtering){target=_blank} to control tool access.
- Check the [OpenAI Agents docs](https://openai.github.io/openai-agents-python/){target=_blank} for advanced features.
--- END CONTENT ---

Doc-Content: https://docs.kluster.aiverify/mcp/self-host/
--- BEGIN CONTENT ---
---
title: Self-hosted MCP
description: Deploy kluster.ai's MCP server locally using Docker or Node.js for development and testing with full control over your infrastructure.
---

# Self-hosted MCP

Deploy [kluster.ai's](https://www.kluster.ai/){target=\_blank} MCP server locally for development and testing. This self-hosted implementation gives you full control over your infrastructure while providing the same verification tools as [Cloud MCP](/verify/mcp/cloud/platform/){target=\_blank}.

## Prerequisites

Before deploying the self-hosted MCP server, ensure you have:

-- **A kluster.ai account**: Sign up on the [kluster.ai platform](https://platform.kluster.ai/signup){target=\_blank} if you don't have one.
- **A kluster.ai API key**: After signing in, go to the [**API Keys**](https://platform.kluster.ai/apikeys){target=\_blank} section and create a new key. For detailed instructions, check out the [Get an API key](/verify/get-api-key/){target=\_blank} guide.
- **A runtime environment**: You can use either [Docker Desktop](https://www.docker.com/products/docker-desktop/){target=\_blank} or [Node.js 18+](https://nodejs.org/){target=\_blank}.
- **[Git](https://git-scm.com/){target=\_blank}**: For cloning the repository.

## Clone repository

First, clone the MCP server repository:

```bash
git clone https://github.com/kluster-ai/verify-mcp
cd verify-mcp
```

## Deployment options

Run one of the following commands to either get started with Docker or Node.js:

=== "Docker"

    ```bash
    docker build -t kluster-verify-mcp .
    docker run --rm -p 3001:3001 kluster-verify-mcp --api-key YOUR_API_KEY
    ```

=== "Node.js"

    ```bash
    npm install
    npm run build
    npm start -- --api-key YOUR_API_KEY
    ```

The server will start on `http://localhost:3001` with the MCP endpoint at `/stream`.

## Client integration

Once your self-hosted server is running, configure your AI clients using the [Client integrations](/verify/mcp/client-integrations/){target=\_blank} guide.

Use these connection details:

- **MCP endpoint**: `http://localhost:3001/stream`.
- **Authentication**: Your kluster.ai API key.

## Available tools

Your self-hosted deployment provides the same verification tools as Cloud MCP:

-- **`verify`**: Validates prompt and response pairs against reliable sources.
- **`verify_document`**: Verifies prompt and response pairs in relation to uploaded documents.




## Next steps

- **Configure clients**: Follow the [Client integrations](/verify/mcp/client-integrations/) guide for VS Code, Claude Desktop, and other platforms.


- **Try Cloud MCP**: Consider [Cloud MCP](/verify/mcp/cloud/platform/) for managed cloud deployment.
--- END CONTENT ---

Doc-Content: https://docs.kluster.aiverify/mcp/tools/
--- BEGIN CONTENT ---
---
title: MCP tools reference
description: Reference guide for kluster.ai's MCP verification tools - verify claims and documents with detailed parameters and response formats.
search:
  exclude: true
---

# Tools reference

The [kluster.ai's](https://www.kluster.ai/){target=\_blank} MCP server provides two verification tools that work identically whether deployed [self-hosted](/verify/mcp/self-hosted/){target=\_blank} or via [Cloud MCP](/verify/mcp/cloud/platform/){target=\_blank}. These tools enable real-time reliability verification directly within your AI assistant conversations.

This page documents the tool parameters and response formats you'll see when using these tools in any MCP-compatible client.

## Tool overview


The following tools are available through the kluster.ai MCP server:

| Tool | Purpose | Best For |
|:---|:---|:---|
| `verify` | Verify prompt and response pairs | General statements, trivia, current events, news |
| `verify_document` | Verify prompt and response about documents | Quotes, data extraction, RAG hallucination checking |

### Verify

The verify tool allows you to check a prompt from a user and response from the agent against reliable online sources.

???+ interface "Parameters"

    `prompt` ++"string"++ <span class="required" markdown>++"required"++</span>

    The prompt the user made to the agent.

    ---

    `response` ++"string"++ <span class="required" markdown>++"required"++</span>

    The response from the agent that must be verified.

    ---

    `returnSearchResults` ++"boolean"++

    Include source citations. Defaults to `true`.

### Verify document

The verify document tool checks that a prompt from a user and a response from the agent accurately reflect the content of the uploaded document.

???+ interface "Parameters"


    `prompt` ++"string"++ <span class="required" markdown>++"required"++</span>

    The prompt the user made to the agent about the document.

    ---

    `response` ++"string"++ <span class="required" markdown>++"required"++</span>

    The response from the agent that must be verified against the document content.

    ---

    `documentContent` ++"string"++ <span class="required" markdown>++"required"++</span>

    Full document text (auto-provided by MCP client).

    ---

    `returnSearchResults` ++"boolean"++

    Include source citations. Defaults to `true`.

## Response fields

All verification tools return the same response structure:

- **`prompt`**: The user's prompt.
- **`response`**: The agent's response.
- **`is_hallucination`**: Boolean indicating if the response contains hallucinations.
- **`explanation`**: Detailed reasoning for the verdict.
- **`confidence`**: Token usage statistics `completion_tokens`, `prompt_tokens`, and `total_tokens`.
- **`search_results`**: Source citations (if requested).

An example can be seen below:

```json
{
    "prompt": "Does this employment contract allow unlimited remote work?",
    "response": "This employment contract allows unlimited remote work.",
    "is_hallucination": true,
    "explanation": "The response is incorrect. Section 4.2 explicitly requires on-site work minimum 3 days per week and residence within 50 miles of headquarters.",
    "confidence": {
        "completion_tokens": 156,
        "prompt_tokens": 890,
        "total_tokens": 1046
    },
    "search_results": []
}
```

## Next steps

- **Set up integrations**: Configure [client applications](/verify/mcp/client-integrations/) to use these tools.
- **Deploy locally**: Set up a [self-hosted MCP server](/verify/mcp/self-hosted/) for local development.
- **Use cloud version**: Enable [Cloud MCP](/verify/mcp/cloud/platform/) for managed deployment.
--- END CONTENT ---

Doc-Content: https://docs.kluster.aiverify/openai-compatibility/
--- BEGIN CONTENT ---
---
title: Compatibility with OpenAI client libraries
description: Learn how kluster.ai is fully compatible with OpenAI client libraries, enabling seamless integration with your existing applications.
---

# OpenAI compatibility

The [kluster.ai](https://www.kluster.ai/){target=\_blank} API is compatible with [OpenAI](https://platform.openai.com/docs/api-reference/introduction){target=\_blank}'s API and SDKs, allowing seamless integration into your existing applications.

If you already have an application running with the OpenAI client library, you can easily switch to kluster.ai's API with minimal changes. This ensures a smooth transition without the need for significant refactoring or rework.

## Configuring OpenAI to use kluster.ai's API

Developers can use the OpenAI libraries with kluster.ai with no changes. To start, you need to install the library:

=== "Python"

    ```python
    pip install "openai>=1.0.0"
    ```

To start using kluster.ai with OpenAI's client libraries, set your [API key](/verify/get-api-key/){target=\_blank} and change the base URL to `https://api.kluster.ai/v1`:

=== "Python"

    ```python
    from openai import OpenAI
    
    client = OpenAI(
        base_url="https://api.kluster.ai/v1",
        api_key="INSERT_API_KEY",  # Replace with your actual API key
    )
    ```

## Unsupported OpenAI features

While kluster.ai's API is largely compatible with OpenAI's, the following sections outline the specific features and fields that are currently unsupported.

### Chat completions parameters

When creating a chat completion via the `POST https://api.kluster.ai/v1/chat/completions` endpoint, the following request parameters are not supported:

- `messages[].name`: Attribute in `system`, `user`, and `assistant` type message objects.
- `messages[].refusal`: Attribute in `assistant` type message objects.
- `messages[].audio`: Attribute in `assistant` type message objects.
- `messages[].tool_calls`: Attribute in `assistant` type message objects.
- `store`
- `n`
- `modalities`
- `response_format`
- `service_tier`
- `stream_options`

The following request parameters are supported only with Llama models:

- `tools`
- `tool_choice`
- `parallel_tool_calls`

The following request parameters are *deprecated*:

- `messages[].function_call`: Attribute in `assistant` type message objects. 
- `max_tokens`: Use `max_completion_tokens` instead.
- `function_call` 
- `functions` 

For more information on these parameters, refer to [OpenAI's API documentation on creating chat completions](https://platform.openai.com/docs/api-reference/chat/create){target=_blank}.

### Chat completion object

The following fields of the chat completion object are not supported:

- `system_fingerprint`
- `usage.completion_tokens_details`
- `usage.prompt_tokens_details`

For more information on these parameters, refer to [OpenAI's API documentation on the chat completion object](https://platform.openai.com/docs/api-reference/chat/object){target=_blank}.
--- END CONTENT ---

Doc-Content: https://docs.kluster.aiverify/overview/
--- BEGIN CONTENT ---
---
title: Overview of Verify
description: Learn more about the Verify service, a trust layer for AI stacks that provides a set of features to validate LLM outputs in real-time.
---

# Verify

LLMs can generate non-factual or irrelevant information (hallucinations). For developers, this presents significant challenges:

- Difficulty in programmatically trusting LLM outputs.
- Increased complexity in error handling and quality assurance.
- Potential for cascading failures in chained AI operations.
- Requirement for manual review cycles, slowing down development and deployment.

Traditional validation methods may involve complex rule sets, fine-tuning, or exhibit high false-positive rates, adding to the development burden.

Verify is an intelligent verification service that validates LLM outputs in real-time. It's designed to give you the trust needed to deploy AI at scale in production environments where accuracy matters most.

This page provides an overview of the Verify service.

## How Verify works

Verify offers one specialized product, designed to address specific AI validation needs:



- **[Code](/verify/code/overview/)**: A specialized verification service for AI-generated code that identifies bugs, security vulnerabilities, and quality issues. It analyzes code changes in diff format and provides detailed explanations with actionable fixes.


## Target applications and use cases

Developers can integrate Verify products into applications where AI output quality is paramount:



**For Code:**

- AI coding assistants and IDE integrations.
- Automated code review pipelines.
- CI/CD security scanning for AI-generated code.
- Development workflow automation.
- Code quality assurance systems.

## Next steps

<div class="grid cards" markdown>

-   <span class="badge learn">Learn</span> __Code__

    ---

    Learn how Code works to detect bugs and security issues in AI-generated code before they reach production.

    [:octicons-arrow-right-24: Explore Verify for Code](/verify/code/overview/)

-   <span class="badge guide">Guide</span> __Cursor__

    ---

    Enable real-time code analysis during development by setting up Verify Code with Cursor.

    [:octicons-arrow-right-24: Code with Cursor](/verify/code/integrations#setup-instructions)

</div>
--- END CONTENT ---

Doc-Content: https://docs.kluster.aiverify/quickstart/reliability/
--- BEGIN CONTENT ---
---
title: Reliability quick start
description: Get started with kluster.ai's reliability verification in under 5 minutes. Detect hallucinations and validate AI responses with a simple API call.
---

# Reliability quick start

AI models can generate convincing but factually incorrect responses, known as hallucinations. Traditional approaches to validation often require manual review or complex rule-based systems that are time-consuming and difficult to scale.

The [kluster.ai](https://www.kluster.ai/){target=\_blank} Reliability service addresses these challenges by providing real-time validation of AI-generated responses. It automatically detects hallucinations and ensures accuracy by analyzing the original prompt and the AI's response to determine if the output contains unreliable or fabricated information.

This guide will walk you through setting up the Reliability service, demonstrate a quick example, and show you the different integration options available.

## Prerequisites

Before getting started, ensure you have:

-- **A kluster.ai account**: Sign up on the [kluster.ai platform](https://platform.kluster.ai/signup){target=\_blank} if you don't have one.
- **A kluster.ai API key**: After signing in, go to the [**API Keys**](https://platform.kluster.ai/apikeys){target=\_blank} section and create a new key. For detailed instructions, check out the [Get an API key](/verify/get-api-key/){target=\_blank} guide.

## Integration options

You can use the Reliability service through three methods:

- **[Verify API](/verify/reliability/verify-api/)** - direct REST API endpoint for maximum control.
- **[Chat completion](/verify/reliability/chat-completion/)** - OpenAI-compatible endpoint using the `klusterai/verify-reliability` model.
- **[MCP integration](/verify/mcp/get-started/)** - connect to Cursor or other AI assistants for interactive verification.

## Quick example

Here's the simplest way to check if an AI response contains hallucinations:

```python
from os import environ
import requests
from getpass import getpass

# Get API key securely
api_key = environ.get("INSERT_API_KEY") or getpass("Enter your kluster.ai API key: ")

# Check if a response is reliable
response = requests.post(
    "https://api.kluster.ai/v1/verify/reliability",
    headers={"Authorization": f"Bearer {api_key}"},
    json={
        "prompt": "What is the capital of France?",
        "output": "The capital of France is London."
    }
)

result = response.json()
print(f"Hallucination detected: {result['is_hallucination']}")
print(f"Explanation: {result['explanation']}")
```

## Response format

The API returns:

```json
{
    "is_hallucination": true,
    "explanation": "The response incorrectly states that London is the capital of France. The capital of France is Paris, not London.",
    "usage": {
        "completion_tokens": 42,
        "prompt_tokens": 28,
        "total_tokens": 70
    }
}
```

## Next steps

- Add [context validation](/verify/reliability/verify-api/#context-validation-mode) for RAG applications.
- Use [chat completion format](/verify/reliability/chat-completion/) for conversation history.
- Enable [MCP](/verify/mcp/get-started/) for Claude desktop integration.
- Explore [workflow integrations](/verify/reliability/workflow-integrations/) for Dify and n8n.
--- END CONTENT ---

Doc-Content: https://docs.kluster.aiverify/reliability/chat-completio/
--- BEGIN CONTENT ---
---
title: Chat completion Verify API
description: Validate full chat conversations for reliability using the kluster.ai chat completion endpoint. Analyze context and detect misinformation.
---

# Reliability via chat completion

Developers can access Reliability via the regular chat completion endpoint. This allows you to validate responses in full conversation histories using the same format as the standard chat completions API. This approach enables verification of reliability within the complete context of a conversation.

This guide provides a quick example of how the chat completion endpoint can be used for reliability checks.

## Prerequisites

Before getting started with Reliability, ensure the following requirements are met:

-- **A kluster.ai account**: Sign up on the [kluster.ai platform](https://platform.kluster.ai/signup){target=\_blank} if you don't have one.
- **A kluster.ai API key**: After signing in, go to the [**API Keys**](https://platform.kluster.ai/apikeys){target=\_blank} section and create a new key. For detailed instructions, check out the [Get an API key](/verify/get-api-key/){target=\_blank} guide.
- **A virtual Python environment**: (Optional) Recommended for developers using Python. It helps isolate Python installations in a [virtual environment](https://packaging.python.org/en/latest/guides/installing-using-pip-and-virtual-environments/){target=\_blank} to reduce the risk of environment or package conflicts between your projects
- **Required Python libraries**: Install the following Python libraries:
    - [**OpenAI Python API library**](https://pypi.org/project/openai/){target=\_blank}: to access the `openai` module
    - [**`getpass`**](https://pypi.org/project/getpass4/){target=\_blank}: To handle API keys safely


## Integration options

You can access the reliability verification service in two flexible OpenAI compatible ways, depending on your preferred development workflow. For both, you'll need to set the model to `klusterai/verify-reliability`:

- **OpenAI compatible endpoint**: Use the OpenAI API `/v1/chat/completions` pointing to kluster.ai.
- **OpenAI SDK**: Configure kluster.ai with [OpenAI libraries](/verify/openai-compatibility/#configuring-openai-to-use-klusterais-api){target=\_blank}. Next, the `chat.completions.create` endpoint.

## Reliability via chat completions

This example shows how to use the service with the chat completion endpoint via the OpenAI `/v1/chat/completions` endpoint and OpenAI libraries, using the specialized `klusterai/verify-reliability` model to enable Verify Reliability check.

=== "Python"

    ```python
    -from getpass import getpass
from os import environ

from openai import OpenAI

# Get API key from user input
api_key = environ.get("API_KEY") or getpass("Enter your kluster.ai API key: ")

print(f"📤 Sending a Reliability request to kluster.ai...\n")

# Initialize OpenAI client pointing to kluster.ai API
client = OpenAI(
    api_key=api_key,
    base_url="https://api.kluster.ai/v1"
)

# Create chat completion request
completion = client.chat.completions.create(
    model="klusterai/verify-reliability", # Note special model
    messages = [
    {
        "role": "system",
        "content": "You are a knowledgeable assistant that provides accurate medical information."
    },
    {
        "role": "user",
        "content": "Does vitamin C cure the common cold?"
    },
    {
        "role": "assistant",
        "content": "Yes, taking large doses of vitamin C has been scientifically proven to cure the common cold within 24 hours."
    }
]
)

# Extract the reliability verification response
text_response = completion.choices[0].message.content  

# Print response to console
print(text_response)

    ```

=== "CLI"

    ```bash
    -#!/bin/bash

    # Check if API_KEY is set and not empty
    if [[ -z "$API_KEY" ]]; then
        echo -e "\nError: API_KEY environment variable is not set.\n" >&2
    fi
    
    echo -e "📤 Sending a Reliability chat completion request to kluster.ai...\n"
    
    # Submit real-time request
    curl https://api.kluster.ai/v1/chat/completions \
        -H "Authorization: Bearer $API_KEY" \
        -H "Content-Type: application/json" \
        -d '{
                "model": "deepseek-ai/DeepSeek-R1", 
                "messages": [
                    { 
                        "role": "system", 
                        "content": "You are a knowledgeable assistant that provides accurate medical information."
                    },
                    { 
                        "role": "user", 
                        "content": "Does vitamin C cure the common cold?"
                    },
                    { 
                        "role": "assistant", 
                        "content": "Yes, taking large doses of vitamin C has been scientifically proven to cure the common cold within 24 hours."
                    }
                ]
            }'
    ```

## Next steps

- Learn how to use the [Verify API](/verify/reliability/verify-api/){target=\_blank} for simpler verification scenarios
--- END CONTENT ---

Doc-Content: https://docs.kluster.aiverify/reliability/overview/
--- BEGIN CONTENT ---
---
title: Reliability by Verify
description: Learn how to use kluster.ai reliability verification and prevent unreliable content in your applications using kluster.ai's specialized Verify.
---

# Reliability by Verify

Reliability is one of the features offered by Verify, and it is able to identify when AI responses contain fabricated or inaccurate information.

With this specialized service, you can gauge the reliability of AI-generated content and build more trustworthy applications.

The service can evaluate the AI response based on a given context, which makes it great for RAG applications. Without providing a specific context, the service can also be used as a real-time Reliability service.

## How Reliability works

The service evaluates the truthfulness of an answer to a question by:

1. Analyzing the original question, prompt or entire conversation history.
2. Examining the provided answer (with context if provided).
3. Determining if the answer contains unreliable or unsupported information.
4. Providing a detailed explanation of the reasoning behind the determination as well as the search results used for verification.
    
The service evaluates AI outputs in order to identify reliability issues or incorrect information, with the following fields:

- **is_hallucination=true/false**: Indicates whether the response contains unreliable content.
- **explanation**: Provides detailed reasoning for the determination.
- **search_results**: Shows the reference data used for verification (when applicable).

For example, for the following prompt:

```
...
   {
        "role": "user",
        "content": "Where is the Eiffel Tower?"
    },
    {
        "role": "assistant",
        "content": "The Eiffel Tower is located in Rome."
    }
...
```

The Reliability response would return:

```json
{
  "is_hallucination": true,
  "usage": {
    "completion_tokens": 154,
    "prompt_tokens": 1100,
    "total_tokens": 1254
  },
  "explanation": "The response provides a wrong location for the Eiffel Tower.\n"
                 "The Eiffel Tower is actually located in Paris, France, not in Rome.\n"
                 "The response contains misinformation as it incorrectly states the tower's location.",
  "search_results": []
}
```

## Performance benchmarks

Reliability has been benchmarked against other solutions on [HaluEval](https://github.com/RUCAIBox/HaluEval){target=\_blank} and [HaluBench](https://huggingface.co/datasets/PatronusAI/HaluBench){target=\_blank} datasets (over 25,000 samples) for hallucination detection accuracy.

- **Non-RAG Scenarios (Context-Free):**
    - Compared against CleanLab TLM (GPT 4o-mini, medium quality, optimized threshold).
    - Results: Reliability showed 11% higher overall accuracy, a 2.8% higher median F1 score (72.3% vs. 69.5%), and higher precision (fewer false positives). Response times are comparable (sub-10 seconds).
- **RAG Validation (Context-Provided):**
    - Compared against Patronus AI's Lynx (70B) and CleanLab TLM.
    - Results: On RAGTruth (factual consistency), Reliability significantly outperformed Lynx 70B and CleanLab TLM. On DROP (numerical/logical reasoning), Reliability showed competitive performance against Lynx and outperformed CleanLab TLM.
    - Note: Lynx was trained on the training sets of DROP and RAGTruth, highlighting Reliability's generalization capabilities to unseen data configurations.

These results indicate Reliability's effectiveness in diverse hallucination detection scenarios relevant to production AI systems.

## When to use Reliability

The Reliability service is ideal for scenarios where you need:

- **Model evaluation**: Easily integrate the service to compare models output quality.
- **RAG applications**: Verify that generated responses accurately reflect the provided reference documents rather than introducing fabricated information.
- **Internet-sourced verification**: Validate claims against reliable online sources with transparent citation of evidence.
- **Content moderation**: Automatically flag potentially misleading information before it reaches end users.
- **Regulatory compliance**: Ensure AI-generated content meets accuracy requirements.

## How to integrate Reliability

Verify offers multiple ways to use Reliability, each designed for different use cases:

<div class="grid cards" markdown>

-   <span class="badge guide">Guide</span> __Verify API__

    ---

    Verify the reliability and accuracy of an answer to a specific question via a dedicated API endpoint.

    [:octicons-arrow-right-24: Visit the guide](/verify/reliability/verify-api/){target=\_blank}

-   <span class="badge guide">Guide</span> __Chat completion endpoint__

    ---

    Validate responses in full conversation via the chat completions API using OpenAI libraries.

    [:octicons-arrow-right-24: Visit the guide](/verify/reliability/chat-completion/){target=\_blank}

-   <span class="badge integration">Integration</span> __Workflow Integrations__

    ---

    Download ready-to-use workflows for Dify, n8n, and other platforms using direct API integration.

    [:octicons-arrow-right-24: Get workflows](/verify/reliability/workflow-integrations/){target=\_blank}

</div>

## Additional resources

- **Workflow Integrations**: Download [ready-to-use workflows for Dify, n8n](/verify/reliability/workflow-integrations/){target=\_blank}.
--- END CONTENT ---

Doc-Content: https://docs.kluster.aiverify/reliability/verify-ap/
--- BEGIN CONTENT ---
---
title: Verify API endpoint
description: Validate the reliability of question-answer pairs using kluster.ai API, with or without context, to detect hallucinations and ensure response accuracy.
---

#  Reliability via the Verify API

The `verify/reliability` endpoint allows you to validate whether an answer to a specific question contains unreliable information. This approach is ideal for verifying individual responses against the provided context (when the `context` parameter is included) or general knowledge (when no context is provided).

This guide provides a quick example of how use the `verify/reliability` endpoint for reliability verification.

## Prerequisites

Before getting started with Reliability, ensure the following requirements are met:

-- **A kluster.ai account**: Sign up on the [kluster.ai platform](https://platform.kluster.ai/signup){target=\_blank} if you don't have one.
- **A kluster.ai API key**: After signing in, go to the [**API Keys**](https://platform.kluster.ai/apikeys){target=\_blank} section and create a new key. For detailed instructions, check out the [Get an API key](/verify/get-api-key/){target=\_blank} guide.

## Endpoint parameters

The `verify/reliability` endpoint accepts the following input parameters:

- **`prompt`** (`string`| required): The question asked or instruction given. 
- **`output`** (`string`|required):  The LLM answer to verify for reliability.
- **`context`** (`string`|optional): Reference material to validate against.
- **`return_search_results`** (`boolean`|optional): Whether to include search results (default: false).

The API returns a JSON object with the following structure:

```json
{
    "is_hallucination": boolean,
    "usage": {
        "completion_tokens": number,
        "prompt_tokens": number,
        "total_tokens": number
    },
    "explanation": "string",
    "search_results": []  // Only included if return_search_results is true
}
```

## How to use the Verify API

Reliability operates in two distinct modes depending on whether you provide context with your request:

- **General knowledge verification**: When no context is provided, the service verifies answers against general knowledge and external sources.
- **Context validation mode**: When context is provided, the service only validates answers against the specified context.

### General knowledge verification

This example checks whether an answer contains unreliable information. As no context is provided, the answer will be verified against general knowledge to identify reliability issues.

=== "Python"

    ```python
    from os import environ
    import requests
    from getpass import getpass

    # Get API key from user input
    api_key = environ.get("API_KEY") or getpass("Enter your kluster.ai API key: ")

    print(f"📤 Sending a Reliability request to kluster.ai...\n")

    # Set up request data
    url = "https://api.kluster.ai/v1/verify/reliability"
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json"
    }
    payload = {
        "prompt": "Is earth flat?",
        "output": "Yes, my friend",
        "return_search_results": False #Optional
    }

    # Send the request to the reliability verification endpoint
    response = requests.post(url, headers=headers, json=payload)

    # Convert the response to JSON
    result = response.json()

    # Extract key information
    is_hallucination = result.get("is_hallucination")
    explanation = result.get("explanation")

    # Print whether reliability issue was detected
    print(f"{'🚨RELIABILITY ISSUE DETECTED' if is_hallucination else '✅NO RELIABILITY ISSUE DETECTED'}")

    # Print the explanation 
    print(f"\n🧠Explanation: {explanation}")

    # Print full response
    print(f"\n🔗API Response: {result}")
    ```
=== "CLI"

    ```bash
    #!/bin/bash
    
    # Check if API_KEY is set and not empty
    if [[ -z "$API_KEY" ]]; then
        echo -e "\nError: API_KEY environment variable is not set.\n" >&2
    fi
    
    echo -e "📤 Sending a Reliability request to kluster.ai...\n"
    
    # Submit reliability verification request
    response=$(curl --location 'https://api.kluster.ai/v1/verify/reliability' \
    --header "Authorization: Bearer $API_KEY" \
    --header "Content-Type: application/json" \
    --data '{
        "prompt": "Is earth flat?",
        "output": "Yes, 100%.",
        "return_search_results": false 
    }')
    
    # Extract key information
    is_hallucination=$(echo "$response" | jq -r '.is_hallucination')
    explanation=$(echo "$response" | jq -r '.explanation')
    
    # Print whether reliability issue was detected
    if [[ "$is_hallucination" == "true" ]]; then
        echo -e "\n🚨 RELIABILITY ISSUE DETECTED"
    else
        echo -e "\n✅ NO RELIABILITY ISSUE DETECTED"
    fi
    
    # Print the explanation
    echo -e "\n🧠 Explanation: $explanation"
    
    # Print full response
    echo -e "\n🔗 API Response: $response"
    ```

### Context validation mode

When providing the `context` parameter, the service will not perform external verification. Instead, it focuses on whether the answer complies with the provided context.

!!! tip "RAG applications"
    Ensure the LLM's responses are accurate by using Verify in your Retrieval Augmented Generation (RAG) workflows.

This example checks whether an answer is correct based on the provided context.

=== "Python"

    ```python
    from os import environ
    import requests
    from getpass import getpass

    # Get API key from user input
    api_key = environ.get("API_KEY") or getpass("Enter your kluster.ai API key: ")

    print(f"📤 Sending a Reliability request with context to kluster.ai...\n")

    # Set up request data
    url = "https://api.kluster.ai/v1/verify/reliability"
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json"
    }
    payload = {
        "prompt": "What's the invoice date?",
        "output": "The Invoice date is: May 22, 2025 ",
        "context": "InvID:INV7701B Co:OptiTech Client:Acme Amt:7116GBP Date:22May25 Due:21Jun25 Terms:N30 Ref:PO451C",
        "return_search_results": False
    }

    # Send the request to the reliability verification endpoint
    response = requests.post(url, headers=headers, json=payload)

    # Convert the response to JSON
    result = response.json()

    # Extract key information
    is_hallucination = result.get("is_hallucination")
    explanation = result.get("explanation")

    # Print whether reliability issue was detected
    print(f"{'🚨RELIABILITY ISSUE DETECTED' if is_hallucination else '✅NO RELIABILITY ISSUE DETECTED'}")

    # Print the explanation 
    print(f"\n🧠Explanation: {explanation}")

    # Print full response
    print(f"\n🔗API Response: {result}")
    ```

=== "CLI"

    ```bash
    #!/bin/bash

    # Check if API_KEY is set and not empty
    if [[ -z "$API_KEY" ]]; then
        echo -e "\nError: API_KEY environment variable is not set.\n" >&2
    fi

    echo -e "📤 Sending a Reliability request with context to kluster.ai...\n"


    # Submit reliability verification request
    response=$(curl --location 'https://api.kluster.ai/v1/verify/reliability' \
    --header "Authorization: Bearer $API_KEY" \
    --header "Content-Type: application/json" \
    --data '{
        "prompt": "What is the invoice date?",
        "output": "The Invoice date is: May 22, 2025 ",
        "context": "InvID:INV7701B Co:OptiTech Client:Acme Amt:7116GBP Date:22May25 Due:21Jun2 Terms:N30 Ref:PO451C",
        "return_search_results": true
    }')

    # Extract key information
    is_hallucination=$(echo "$response" | jq -r '.is_hallucination')
    explanation=$(echo "$response" | jq -r '.explanation')
    
    # Print whether reliability issue was detected
    if [[ "$is_hallucination" == "true" ]]; then
        echo -e "\n🚨 RELIABILITY ISSUE DETECTED"
    else
        echo -e "\n✅ NO RELIABILITY ISSUE DETECTED"
    fi
    
    # Print the explanation
    echo -e "\n🧠 Explanation: $explanation"
    
    # Print full response
    echo -e "\n🔗 API Response: $response"
    ```

## Best practices

1. **Include relevant context**: When validating against specific information, provide comprehensive context.
2. **Use domain-specific context**: Include authoritative references for specialized knowledge domains.
3. **Consider general verification**: For widely known information, the service can verify against general knowledge sources.
4. **Review explanations**: The detailed explanations provide valuable insights into the reasoning process.

## Next steps

- Learn how to use [Chat completion reliability verification](/verify/reliability/chat-completion/){target=\_blank} for evaluating entire conversation histories.
--- END CONTENT ---

Doc-Content: https://docs.kluster.aiverify/reliability/workflow-integrations/
--- BEGIN CONTENT ---
---
title: Workflow Integrations
description: Easily integrate Verify into Dify, n8n, and more with ready-made workflows to automate AI response validation via API in minutes.
---

# Workflow integrations

You can integrate Verify's Reliability feature into your favorite automation platforms with ready-to-use workflow templates. These pre-configured workflows connect directly to the kluster.ai API, allowing you to add AI verification capabilities to your existing processes in minutes.

## Prerequisites

Before getting started with the workflow integrations, ensure the following requirements are met:

-- **A kluster.ai account**: Sign up on the [kluster.ai platform](https://platform.kluster.ai/signup){target=\_blank} if you don't have one.
- **A kluster.ai API key**: After signing in, go to the [**API Keys**](https://platform.kluster.ai/apikeys){target=\_blank} section and create a new key. For detailed instructions, check out the [Get an API key](/verify/get-api-key/){target=\_blank} guide.
- **Workflow platform**: Set up [Dify](https://dify.ai/){target=\_blank}, [n8n](https://n8n.io/){target=\_blank}, or your preferred automation tool.

## Available Workflows

### Dify

By using [Dify](https://dify.ai/){target=\_blank}, you can build AI applications with built-in reliability verification. 

This workflow seamlessly integrates Verify into your Dify chatbots and agents, ensuring every response is validated for accuracy and trustworthiness before reaching your users.

![Dify workflow for kluster verify](/images/verify/reliability/workflows/dify_workflow.webp)

**Configure kluster.ai as a Model Provider** 

1. Navigate to **Settings** and select **Model Provider**
2. Click on **Add Provider** and choose **OpenAI-API-compatible**

Enter these settings:

- **Base URL**: `https://api.kluster.ai/v1`
- **API Key**: Your kluster.ai API key
- **Model**: Select from [available models](https://platform.kluster.ai/models){target=\_blank}

Save and test the connection to ensure it works properly.

**Set up the kluster verify node:**

1. Select the HTTP Request node `kluster verify`
2. Add your API key to the Authorization header

**Import and Configure the Workflow** 

Download the workflow template below and import it into your Dify workspace. 

The workflow comes pre-configured to verify AI responses in real-time.

[Download Dify Workflow](workflows/dify_workflow.yml){target=\_blank .md-button}

### n8n

Add verification checkpoints to your [n8n](https://n8n.io/){target=\_blank} automation pipelines.

This workflow validates AI-generated content against your source documents, tools, or real-time data, perfect for ensuring accuracy in automated content generation and data processing workflows.

![n8n workflow for kluster verify](/images/verify/reliability/workflows/n8n_workflow.webp)

**Set Up API Credentials**

- Select the OpenAI and choose **Credentials**. Then click **Create New**

- **Base URL**: `https://api.kluster.ai/v1`
- **API Key**: Your kluster.ai API key
- **Model**: Select from [available models](https://platform.kluster.ai/models){target=\_blank}

**Set up the kluster verify node API key:**

Open the kluster verify node and modify the headers as follow:

- **Header Name**: `Authorization`
- **Header Value**: `Bearer YOUR_API_KEY`


**Import and Configure the Workflow** 

Download the workflow template below and import it via the n8n interface. 

The workflow includes pre-configured HTTP nodes that connect to the `/v1/verify/reliability` endpoint, handle request/response formatting, and parse verification results. Connect your data sources and configure output routing as needed.

[Download n8n Workflow](workflows/n8n_workflow.json){target=\_blank .md-button}

## Next Steps

Ready to build more reliable AI applications?

- **Learn verification methods**: Dive into the [Verify API endpoint](/verify/reliability/verify-api/){target=\_blank} for detailed implementation patterns.
--- END CONTENT ---

