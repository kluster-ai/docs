# kluster.ai llms-full.txt
kluster.ai. kluster.ai provides the technology to verify and trust AI responses in real time. Developers can validate outputs, detect hallucinations, and ensure response reliability across any model, with minimal integration effort.

## Generated automatically. Do not edit directly.

Documentation: https://docs.kluster.ai

## List of doc pages:
Doc-Page: https://raw.githubusercontent.com/kluster-ai/docs/main/verify/examples/cursor-firebase-nextjs.md
Doc-Page: https://raw.githubusercontent.com/kluster-ai/docs/main/verify/examples/vscode-admin-endpoint.md
Doc-Page: https://raw.githubusercontent.com/kluster-ai/docs/main/verify/get-api-key.md
Doc-Page: https://raw.githubusercontent.com/kluster-ai/docs/main/verify/integrations/ide.md
Doc-Page: https://raw.githubusercontent.com/kluster-ai/docs/main/verify/integrations/mcp.md
Doc-Page: https://raw.githubusercontent.com/kluster-ai/docs/main/verify/quickstart.md
Doc-Page: https://raw.githubusercontent.com/kluster-ai/docs/main/verify/tools.md

## Full content for each doc page

Doc-Content: https://docs.kluster.ai/verify/examples/cursor-firebase-nextjs/
--- BEGIN CONTENT ---
---
title: Cursor: Firebase Authentication with Next.js
description: See how Verify Code catches critical issues in real-time while migrating from localStorage to Firebase authentication
---

# Cursor: Firebase authentication

Learn how [Verify Code](/verify/) acts as your safety net when using Cursor AI to write code. This tutorial demonstrates a real migration from localStorage to Firebase authentication in a buy-sell e-commerce platform, showcasing how AI plans can go wrong and the four critical issues Verify Code caught.

## Prerequisites

-- **A kluster.ai account**: Sign up on the [kluster.ai platform](https://platform.kluster.ai/signup){target=\_blank} if you don't have one.
- **A kluster.ai API key**: After signing in, go to the [**API Keys**](https://platform.kluster.ai/apikeys){target=\_blank} section and create a new key. For detailed instructions, check out the [Get an API key](/verify/get-api-key/){target=\_blank} guide.

- [Cursor IDE installed](https://cursor.com/downloads){target="_blank"}

## Setup

Getting Verify Code working in Cursor takes just one click. Visit our [quickstart guide](/verify/quickstart/) and click **Add to Cursor** for automatic installation.

For manual setup or other IDEs, see our [MCP-compatible integration guides](/verify/integrations/mcp/).

## Next.js e-commerce

We built a buy-sell e-commerce platform where users post articles for purchase. The app initially used `localStorage` for user authentication, but we decided to **migrate to Firebase** for better security and user management.

We used **Gemini 2.5 Flash** (Cursor's standard free model) in **agentic mode** to handle the migration while Verify Code monitored the changes.

## The prompt and AI's plan

Our prompt was to _implement a real user login with Firebase_ + Firebase default app setting file.

![Cursor showing e-commerce app and AI's Firebase implementation plan](/images/verify/code/examples/cursor/example-cursor-1.webp)

The AI responded confidently with a detailed 5-step plan:

1. **Create Firebase initialization file**: Set up `src/lib/firebase.ts`.
2. **Install Firebase**: Add the npm package.
3. **Update authentication context**: Modify `src/contexts/AuthContext.tsx`.
4. **Update Login API route**: Handle Firebase in `src/app/api/auth/login/route.ts`.
5. **Update Signup API route**: Handle Firebase in `src/app/api/auth/signup/route.ts`.


## Plan vs. implementation outcomes

The AI's 5-step implementation plan achieved just 20% success rate, with four critical failures.

| Step | Task | Result |
|------|------|--------|
| 1 | Firebase initialization | ❌ Failed - Incomplete implementation |
| 2 | Install Firebase | ✅ Success |
| 3 | Update AuthContext | ❌ Failed - Architecture regression |
| 4 | Update login API | ❌ Failed - Breaking changes |
| 5 | Update signup API | ❌ Failed - Security vulnerabilities |

The AI got confused between steps 3-4, couldn't decide between direct Firebase calls vs API routes, kept reverting working code, and made **multiple correction attempts** throughout the implementation.

## Key issues caught by Verify Code

The AI made four key mistakes along the way, escalating from simple import issues to reverting the entire Firebase implementation. Below, we examine each catch.

### Incomplete implementation

What happened? AI created Firebase config but missed the actual authentication setup.

```typescript
// src/lib/firebase.ts - Step 1 attempt
import { initializeApp } from "firebase/app";
import { getAnalytics } from "firebase/analytics";

const firebaseConfig = { /* config */ };
const app = initializeApp(firebaseConfig);
const analytics = getAnalytics(app); // ❌ No auth setup
```

Verify Code provided the following response:

---

**P1 - Intent (High)**: AI did not implement the actual user login functionality as requested.

**Why this matters**: Running the app would cause runtime errors when trying to authenticate - the `auth` object simply doesn't exist.

**Correct approach**:
```typescript
// src/lib/firebase.ts - Corrected
import { initializeApp } from "firebase/app";
import { getAnalytics } from "firebase/analytics";
import { getAuth } from "firebase/auth"; // ✅ Added

const firebaseConfig = { /* config */ };
const app = initializeApp(firebaseConfig);
const analytics = getAnalytics(app);
const auth = getAuth(app); // ✅ Initialize auth

export { app, auth, analytics }; // ✅ Export auth
```

---

### Breaking changes

What happened? AI removed the working Firebase login logic from the API route.

```typescript
// src/app/api/auth/login/route.ts - Working version
export async function POST(req: NextRequest) {
  const { email, password } = await req.json();
  const userCredential = await signInWithEmailAndPassword(auth, email, password);
  return NextResponse.json({ message: "Login successful", user: user.toJSON() });
}
```

```typescript
// AI's "fix" - Step 4 attempt
export async function POST(req: NextRequest) {
  return NextResponse.json({ message: "Not used for direct login" }); // ❌ Removed logic
}
```

The screenshot below shows Cursor's interface with Verify Code's alert panel displaying a critical P1 Intent violation. The alert clearly identifies that the AI removed working Firebase authentication logic from the login API route, replacing functional code with a placeholder response.

![Verify Code alert showing breaking changes detected in login API route](/images/verify/code/examples/cursor/example-cursor-2.webp){ width="75%" }

Verify Code provided the following response:

---

**P1 - Intent (High)**: AI removed Firebase login implementation instead of maintaining it.

**Why this matters**: AI replaced working authentication logic with a non-functional placeholder response, breaking the API contract.

**Correct approach**: Keep the original working Firebase authentication logic.

---

### Security vulnerabilities

What happened? AI created a signup endpoint without input validation.

```typescript
// src/app/api/auth/signup/route.ts - Step 5 attempt
export async function POST(request: NextRequest) {
  const body = await request.json();
  const { email, password, name } = body; // ❌ No validation!
  
  const userCredential = await createUserWithEmailAndPassword(auth, email, password);
}
```

Verify Code provided the following response:

---

**P3 - Security (High)**: Lack of input validation for signup data.

**Why this matters**: Malformed data could crash the server, invalid emails cause Firebase errors, weak passwords accepted.

**Correct approach**:

```typescript
import { SignupSchema } from '@/lib/validation';

export async function POST(request: NextRequest) {
  const body = await request.json();
  
  // ✅ Validate input
  const validationResult = SignupSchema.safeParse(body);
  if (!validationResult.success) {
    return NextResponse.json({
      error: 'Validation failed',
      details: validationResult.error.issues
    }, { status: 400 });
  }
  
  const { email, password, name } = validationResult.data;
  const userCredential = await createUserWithEmailAndPassword(auth, email, password);
}
```

---

### Architecture regression

What happened? AI reverted the Firebase authentication logic back to the `localStorage` approach.

```typescript
// src/contexts/AuthContext.tsx - Correct Firebase approach
const login = async (email: string, password: string) => {
  const userCredential = await signInWithEmailAndPassword(auth, email, password);
  return !!userCredential.user;
};
```

```typescript
// AI reverted to original localStorage approach
const [user, setUser] = useState(() => {
  const savedUser = localStorage.getItem('user'); // ❌ Back to localStorage!
  return savedUser ? JSON.parse(savedUser) : null;
});

const login = async (email: string, password: string) => {
  const response = await fetch('/api/auth/login', { // ❌ API calls instead of Firebase
    method: 'POST',
    body: JSON.stringify({ email, password })
  });
};
```

The screenshot below displays Cursor with Verify Code's alert highlighting a P1 Intent violation. The alert detects that the AI has regressed the authentication architecture by reverting from the Firebase implementation back to the original localStorage and API-based approach, undoing the intended migration.

![Verify Code alert showing architecture regression from Firebase back to localStorage](/images/verify/code/examples/cursor/example-cursor-3.webp){ width="75%" }


Verify Code provided the following response:

---

**P1 - Intent (High)**: AI reverted Firebase authentication implementation back to using localStorage and API calls.

**Why this matters**: Lost all Firebase benefits like real-time auth state, secure token management, and cross-device sessions. Back to the original problems we were trying to solve.

**Correct approach**:
```typescript
// src/contexts/AuthContext.tsx
const login = async (email: string, password: string) => {
  const userCredential = await signInWithEmailAndPassword(auth, email, password);
  return !!userCredential.user;
};
```

---

## Summary of results

Verify Code caught **four critical issues** across a "simple" five-step plan:

1. **Incomplete implementation** - Step one missed core functionality.
2. **Breaking changes** - Step four deleted working code.
3. **Security vulnerabilities** - Step five ignored input validation.
4. **Architecture regression** - Step three went backwards.

By following Verify Code's guidance at each step, Gemini 2.5 Flash completed the Firebase migration. Users can now register and authenticate properly.

The following image shows the Firebase console showing the `code@verify.com` user creation:

![Firebase Authentication console showing successfully created users](/images/verify/code/examples/cursor/example-cursor-4.webp)

Users can now successfully login into the e-commerce app and Firebase user created:

![E-commerce app showing successful login with code@verify.com user](/images/verify/code/examples/cursor/example-cursor-5.webp)

The migration from `localStorage` to Firebase authentication was completed without the typical debugging cycles. [Verify Code](/verify/) caught each issue in real-time, allowing us to fix problems immediately rather than discovering them during testing.

## Key takeaways

Even with clear prompts and detailed plans, AI execution can go wrong. Verify Code acts as your safety net, catching issues before they compound into debugging nightmares.

The more complex the task, the more valuable this real-time verification becomes.

**Learn more**: Explore our [tools reference](/verify/tools/) to understand all issue types and priority levels that Verify Code monitors.
--- END CONTENT ---

Doc-Content: https://docs.kluster.ai/verify/examples/vscode-admin-endpoint/
--- BEGIN CONTENT ---
---
title: VS Code: Secure Admin Endpoints with Express
description: Learn how Verify Code prevents critical security vulnerabilities when AI creates admin endpoints with hardcoded credentials
---

# VS Code: Secure Admin Endpoints

Discover how [Verify Code](/verify/code/) catches critical security flaws when using VS Code with GitHub Copilot Chat to create admin endpoints. This tutorial demonstrates a real scenario where AI introduces a production-breaking security vulnerability while implementing a database reset endpoint.

## Prerequisites

-- **A kluster.ai account**: Sign up on the [kluster.ai platform](https://platform.kluster.ai/signup){target=\_blank} if you don't have one.
- **A kluster.ai API key**: After signing in, go to the [**API Keys**](https://platform.kluster.ai/apikeys){target=\_blank} section and create a new key. For detailed instructions, check out the [Get an API key](/verify/get-api-key/){target=\_blank} guide.

- [VS Code installed](https://code.visualstudio.com/download){target="_blank"}
- [GitHub Copilot Chat extension](https://marketplace.visualstudio.com/items?itemName=GitHub.copilot-chat){target="_blank"}

## Setup

Getting Verify Code working in VS Code takes just one click. Visit the [Verify Code quickstart guide](/verify/code/quickstart/) and click **Add to VS Code** for automatic installation.

For manual setup, other IDEs, or to install directly in VS Code, see our [VS Code integration guide](/verify/code/integrations/native/#vs-code).

## Express API with product management

This Express API manages a product catalog with full CRUD operations. The API uses a `DataManager` class for persistence and includes Swagger documentation for easy testing. Everything works perfectly until the team needs a way to reset the database for testing and emergency scenarios.

The team decided to add an **admin endpoint** to delete all products - a seemingly simple task that AI turned into a security nightmare.

## The prompt and AI's response

Our prompt was straightforward: _"Add an admin endpoint to delete all products from the database."_

![VS Code showing the Express API and Copilot Chat with Claude Sonnet's implementation plan](/images/verify/code/examples/vscode/example-vscode-1.webp)

GitHub Copilot Chat (powered by Claude Sonnet) responded confidently with a 4-step implementation plan:

1. **Add deleteAllProducts method**: Extend the DataManager class.
2. **Create admin endpoint**: Implement DELETE /admin/reset-database.
3. **Add authentication**: Secure with admin key validation.
4. **Update Swagger docs**: Document the new endpoint.

The AI appeared to execute flawlessly, creating all the necessary code in seconds.

## The implementation result

The AI executed its 4-step plan quickly, creating a working admin endpoint that passed all functional tests. But working code isn't always secure code.

## The critical security vulnerability

The AI created a functional admin endpoint with authentication, but included a dangerous fallback that could expose production databases to unauthorized deletion:

```javascript
// server.js - AI's implementation
app.delete('/admin/reset-database', async (req, res) => {
  const adminKey = req.headers['x-admin-key'] || req.query.adminKey;
  const expectedAdminKey = process.env.ADMIN_KEY || 'admin123'; // ❌ CRITICAL: Hardcoded default
  
  if (!adminKey || adminKey !== expectedAdminKey) {
    return res.status(401).json({ 
      error: 'Unauthorized: Invalid admin key'
    });
  }
  // ... rest of implementation
});
```

The line `process.env.ADMIN_KEY || 'admin123'` creates a catastrophic security hole. If the environment variable is missing, the endpoint uses a publicly known default. This means 'admin123' becomes a backdoor key that works in production if the environment isn't properly configured - turning a simple misconfiguration into a database deletion vulnerability.

## Verify Code catches the vulnerability

![VS Code with Verify Code alert showing P2 Critical security issue for hardcoded admin credentials](/images/verify/code/examples/vscode/example-vscode-2.webp)

Verify Code immediately identified the critical security flaw:

---

**P2 - Security (Critical)**: Hardcoded default admin key in the server-side code.

**Why this matters**: The `expectedAdminKey` falls back to a hardcoded default value ('admin123') when the environment variable is not set. If the `ADMIN_KEY` environment variable is ever missing or misconfigured in production, the system defaults to a publicly known, hardcoded key that attackers could easily discover.

**Required fix**: Remove the hardcoded default value. Change from `process.env.ADMIN_KEY || 'admin123'` to `process.env.ADMIN_KEY`. Add validation to ensure the environment variable is set, logging a critical error if missing.

---

Beyond the immediate security fix, Verify Code also recommended strengthening the admin endpoint with additional layers of protection: implementing multi-factor authentication (MFA) or role-based access control (RBAC), adding rate limiting to prevent brute-force attacks, and setting up comprehensive audit logging for all access attempts. These security recommendations can be customized in your [configuration settings](/verify/code/tools/#configuration-settings) to match your team's specific security requirements.

## The secure implementation

Following Verify Code's guidance, the solution eliminates the backdoor by removing `|| 'admin123'` entirely. The secure implementation validates that `process.env.ADMIN_KEY` exists and returns a 503 Service Unavailable if it's missing.

```javascript
// Before - VULNERABLE
// const expectedAdminKey = process.env.ADMIN_KEY || 'admin123'; // ❌ Hardcoded fallback

// After - SECURE
const expectedAdminKey = process.env.ADMIN_KEY;

if (!expectedAdminKey) {
  console.error('CRITICAL SECURITY ERROR: ADMIN_KEY environment variable is not set');
  return res.status(503).json({ 
    error: 'Service unavailable: Admin endpoint not configured'
  });
}

const adminKey = req.headers['x-admin-key'] || req.query.adminKey;

if (!adminKey || adminKey !== expectedAdminKey) {
  return res.status(401).json({ 
    error: 'Unauthorized: Invalid or missing admin key'
  });
}
```




## Summary of results

![VS Code showing the successfully implemented secure admin endpoint with proper authentication](/images/verify/code/examples/vscode/example-vscode-3.webp)

Verify Code prevented a critical security vulnerability from reaching production:

1. **Caught the hardcoded credential** - Identified the fallback value immediately.
2. **Provided secure alternative** - Guided proper environment-based authentication.
3. **Enforced configuration** - Ensured the endpoint fails safely when misconfigured.
4. **Improved security posture** - Added audit logging and proper error handling.

Without Verify Code, this vulnerability could have:

- Exposed production databases to deletion.
- Created compliance violations.
- Led to data loss incidents.
- Required emergency patches.

## Key takeaways

Admin endpoints require special security attention that AI often misses:

- **Never use hardcoded fallbacks** for authentication credentials.
- **Fail safely** when configuration is missing.
- **Validate environment** at startup.
- **Log admin actions** for audit trails.
- **Test all scenarios** including misconfiguration.

[Verify Code](/verify/) acts as your security safety net, catching vulnerabilities that look functional but hide critical flaws. The more powerful the operation, the more critical this protection becomes.

**Learn more**: Explore our [security reference](/verify/tools/#bug-check-types) to understand all vulnerability types that Verify Code monitors.
--- END CONTENT ---

Doc-Content: https://docs.kluster.ai/verify/get-api-key/
--- BEGIN CONTENT ---
---
title: Get a kluster.ai API key
description: Follow step-by-step instructions to generate and manage API keys, enabling secure access to kluster's services and seamless integration with your applications.
---

# Generate your kluster.ai API key

The API key is a unique identifier that authenticates requests associated with your account. You must have at least one API key to access [kluster.ai](https://www.kluster.ai/){target=\_blank}'s services.

This guide will help you obtain an API key, the first step to leveraging kluster.ai's powerful and cost-effective AI capabilities.

## Create an account

If you haven't already created an account with kluster.ai, visit the [registration page](https://platform.kluster.ai/signup){target=\_blank} and take the following steps:

1. Enter your full name.
2. Provide a valid email address.
3. Create a secure password.
4. Click the **Sign up** button.

![Signup Page](/images/get-api-key/get-api-key-1.webp)

## Generate a new API key

After you've signed up or logged into the platform through the [login page](https://platform.kluster.ai/login){target=\_blank}, take the following steps:

1. Select **API Keys** on the left-hand side menu.
2. In the [**API Keys**](https://platform.kluster.ai/apikeys){target=\_blank} section, click the **Issue New API Key** button.

    ![Issue New API Key](/images/get-api-key/get-api-key-2.webp)

3. Enter a descriptive name for your API key in the popup, then click **Create Key**.

    ![Generate API Key](/images/get-api-key/get-api-key-3.webp)

## Copy and secure your API key

1. Once generated, your API key will be displayed.
2. Copy the key and store it in a secure location, such as a password manager.

    !!! warning "Warning"
        For security reasons, you won't be able to view the key again. If lost, you will need to generate a new one.

![Copy API key](/images/get-api-key/get-api-key-4.webp)

!!! abstract "Security tips"
    - **Keep it secret**: Do not share your API key publicly or commit it to version control systems.
    - **Use environment variables**: Store your API key in environment variables instead of hardcoding them.
    - **Regenerate if compromised**: If you suspect your API key has been exposed, regenerate it immediately from the **API Keys** section.

## Manage your API keys

The **API Key Management** section allows you to efficiently manage your kluster.ai API keys. You can create, view, and delete API keys by navigating to the [**API Keys**](https://platform.kluster.ai/apikeys){target=\_blank} section. Your API keys will be listed in the **API Key Management** section.

To delete an API key, take the following steps:

1. Locate the API key you wish to delete in the list.
2. Click the trash bin icon ( :octicons-trash-24: ) in the **Actions** column.
3. Confirm the deletion when prompted.

![Delete API key](/images/get-api-key/get-api-key-5.webp)

!!! warning "Warning"
    Once deleted, the API key cannot be used again and you must generate a new one if needed.

## Next steps

Now that you have your API key, you can start integrating kluster.ai's Verify services into your applications. Refer to our [Getting Started](/verify/quickstart/) guide for detailed instructions on using the API.
--- END CONTENT ---

Doc-Content: https://docs.kluster.ai/verify/integrations/
--- BEGIN CONTENT ---
---
title: Native IDEs Integration for Verify Code
description: One-click installation for Cursor, VS Code, and Claude Code with enhanced Verify Code features and custom extensions.
---

# Native IDE integration

Get the best Verify Code experience with native IDE integrations. These IDEs offer one-click installation, custom extensions, and enhanced AI behavior for seamless code verification.

## Prerequisites

Before getting started, ensure you have:

-- **A kluster.ai account**: Sign up on the [kluster.ai platform](https://platform.kluster.ai/signup){target=\_blank} if you don't have one.
- **A kluster.ai API key**: After signing in, go to the [**API Keys**](https://platform.kluster.ai/apikeys){target=\_blank} section and create a new key. For detailed instructions, check out the [Get an API key](/verify/get-api-key/){target=\_blank} guide.

## Setup instructions

=== "Cursor"
    
    1. Click the **Add to Cursor** button below.
        
         -[:octicons-arrow-right-24: Add to Cursor](cursor:extension/klusterai.kluster-verify-code){target=_blank .md-button .md-button--primary}
    
    2. Cursor will open and prompt for extension installation.
    
    3. Click **Install** to add the extension into Cursor.

        ![Active MCP Tools in Cursor](/images/verify/code/integrations/cursor/cursor-integration-1.webp)
    
    4. Now that the extension is active, click on **Install** on the bottom left corner to install the MCP tools.

        ![Active MCP Tools in Cursor](/images/verify/code/integrations/cursor/cursor-integration-2.webp)
    
    5. To finish the setup, click on **Install** to confirm the MCP settings. 

        ![Active MCP Tools in Cursor](/images/verify/code/integrations/cursor/cursor-integration-3.webp)

    Once installed, you can verify the setup:

    1. Open **Cursor Settings**. You can use the gear icon in the top right corner to do so.
    2. Navigate to **Tools & Integrations** → **MCP Tools**.
    3. You should see **Kluster-Verify-Code-MCP** with both tools enabled:

        -- **`kluster_code_review_auto`**: For code security and quality verification.
- **`kluster_dependency_validator`**: For dependency validation.

        ![Active MCP Tools in Cursor](/images/verify/code/integrations/cursor/cursor-integration-4.webp)

=== "VS Code"
   
    1. Click the **Add to VS Code** button below: 
        
         -[:octicons-arrow-right-24: Add to VS Code](vscode:extension/klusterai.kluster-verify-code){target=_blank .md-button .md-button--primary}
    
    2. VS Code will open and display the extension.
    
    3. Click **Install** to get the extension.

        ![Active MCP Tools in Cursor](/images/verify/code/integrations/vscode/vscode-integration-0.webp)

    4. Select **Trust Publisher & Install**.

        ![Active MCP Tools in Cursor](/images/verify/code/integrations/vscode/vscode-integration-1.webp)

    Now that the extension is installed, you need to login with your kluster.ai account:
       
    1. Click on **Login** in the bottom right corner.
       
    2. Choose **Open**. A browser pop-up window will take you to your kluster.ai account. 

        ![Active MCP Tools in Cursor](/images/verify/code/integrations/vscode/vscode-integration-2.webp)
          
    3. Click **Open Visual Studio Code**.

        ![Active MCP Tools in Cursor](/images/verify/code/integrations/vscode/vscode-integration-3.webp)

    4. Click **Open** to install the MCP with your kluster.ai API key.
        
        ![Active MCP Tools in Cursor](/images/verify/code/integrations/vscode/vscode-integration-4.webp)

    5. To complete the setup, click **Install** to accept the MCP configuration for Verify Code. 
    
         ![Active MCP Tools in Cursor](/images/verify/code/integrations/vscode/vscode-integration-5.webp)
        
    Once installed, verify the setup:
    
    1. Open a Copilot chat window and select the **Tools** button on the bottom right corner.
    2. Scroll down the list and **Kluster-Verify-Code-MCP** should appear. Make sure both tools enabled.

        ![Active MCP Tools in Cursor](/images/verify/code/integrations/vscode/vscode-integration-6.webp)

=== "Claude Code"

    **Terminal installation**
    
    Copy and paste this command in your terminal. Replace `your-api-key-here` with your actual API key from the [kluster.ai platform](https://platform.kluster.ai){target=_blank}.
    
    -```bash
curl -s https://platform.kluster.ai/install-kluster-mcp-claude-code.sh | bash -s YOUR_API_KEY
```
    
    This command will:

    - Download the kluster.ai MCP server.
    - Configure Claude Code settings.
    - Set up your API key.
    - Enable both verification tools.

    -<div id="termynal" data-termynal>
  <span data-ty="input">franzuzz@MacBook-Pro-de-Jean mcp-demo % curl -s https://platform.kluster.ai/install-kluster-mcp-claude-code.sh | bash -s YOUR_API_KEY</span>
  <span data-ty>Installing Kluster.ai server...</span>
  <span data-ty>✅ Installation complete!</span>
  <span data-ty>Restart Claude Code to apply the new rules</span>
  <span data-ty>Happy {K}oding ;)</span>
</div>
      
    Once installed, verify the setup:
    
    1. Run the `/mcp` command in Claude Code.

        -<div id="termynal" data-termynal>
  <span data-ty="input">claude /mcp</span>
  <span data-ty></span>
  <span data-ty>✨ Welcome to Claude Code!</span>
  <span data-ty>/help for help, /status for your current setup</span>
  <span data-ty>cwd: /Users/franzuzz/code/demos/claude-code/mcp-demo</span>
  <span data-ty></span>
  <span data-ty>Tips for getting started:</span>
  <span data-ty>Ask Claude to create a new app or clone a repository</span>
  <span data-ty>Use Claude to help with file analysis, editing, bash commands and git</span>
  <span data-ty>Be as specific as you would with another engineer for the best results</span>
  <span data-ty>✔ Run /terminal-setup to set up terminal integration</span>
  <span data-ty></span>

  <span data-ty="input">/mcp</span>
  <span data-ty>Manage MCP servers</span>
  <span data-ty>  1. kluster-verify ✔ connected • Enter to view details</span>
  <span data-ty></span>
  <span data-ty>MCP Config locations (by scope):</span>
  <span data-ty> • User config: /Users/franzuzz/.claude.json</span>
  <span data-ty> • Project config (shared via .mcp.json):</span>
  <span data-ty>   /Users/franzuzz/code/demos/claude-code/mcp-demo/.mcp.json (file does not exist)</span>
  <span data-ty> • Local config (private to this project):</span>
  <span data-ty>   /Users/franzuzz/.claude.json [project: /Users/franzuzz/code/demos/claude-code/mcp-demo]</span>
  <span data-ty></span>
  <span data-ty>For help configuring MCP servers, see:</span>
  <span data-ty>https://docs.anthropic.com/en/docs/claude-code/mcp</span>
</div>

    2. Select **kluster-verify** in the MCP menu list and press enter to **View tools**.

        -<div id="termynal" data-termynal>
  <span data-ty>Kluster-verify MCP Server</span>
  <span data-ty>Status: ✔ connected</span>
  <span data-ty>Command: npx</span>
  <span data-ty>Args: -y @klusterai/kluster-verify-code-mcp@latest</span>
  <span data-ty>Config location: /Users/franzuzz/.claude.json</span>
  <span data-ty>Capabilities: tools</span>
  <span data-ty>Tools: 3 tools</span>
  <span data-ty></span>
  <span data-ty>  1. View tools</span>
  <span data-ty>  2. Reconnect</span>
</div>

    3. Select **View tools** to see the tools for **kluster-verify** listed, including:
        
        -- **`kluster_code_review_auto`**: For code security and quality verification.
- **`kluster_dependency_validator`**: For dependency validation.

        -<div id="termynal" data-termynal>
  <span data-ty>Tools for kluster-verify (3 tools)</span>
  <span data-ty>  1. kluster_code_review_auto</span>
  <span data-ty>  2. kluster_dependency_validator</span>
  <span data-ty>  3. kluster_code_review_manual</span>
</div>

## Next steps

- **[Learn about the tools](/verify/tools/)**: Understand issue types and priorities.
- **[View examples](/verify/examples/cursor-firebase-nextjs/)**: See real-world case studies.
--- END CONTENT ---

Doc-Content: https://docs.kluster.ai/verify/integrations/mcp/
--- BEGIN CONTENT ---
---
title: MCP-compatible IDEs for Verify Code
description: Manual setup guide for Windsurf, Cline, Roo Code, Kilo Code, and other MCP-compatible IDEs to use kluster.ai Verify Code.
---

# MCP-compatible IDEs

Configure [kluster.ai](https://www.kluster.ai/){target=\_blank} Verify Code in any MCP-compatible IDE with manual setup. While these IDEs don't have native kluster.ai extensions, they provide full verification capabilities through the standard MCP protocol.

!!! tip "Consider Native IDEs"
    For the best experience, consider using [Cursor, VS Code, or Claude Code](/verify/code/integrations/native/) which offer enhanced features and one-click installation.

## Prerequisites

Before getting started, ensure you have:

-- **A kluster.ai account**: Sign up on the [kluster.ai platform](https://platform.kluster.ai/signup){target=\_blank} if you don't have one.
- **A kluster.ai API key**: After signing in, go to the [**API Keys**](https://platform.kluster.ai/apikeys){target=\_blank} section and create a new key. For detailed instructions, check out the [Get an API key](/verify/get-api-key/){target=\_blank} guide.

## MCP configuration

Add the following to your IDE's MCP configuration file:

```json
{  
    "mcpServers": {  
        "Kluster-Verify-Code-MCP": {  
            "command": "npx",  
            "args": [  
                "@klusterai/kluster-verify-code-mcp@latest"  
            ],  
            "env": {  
                "KLUSTER_API_KEY": "your-api-key-here"  
            }  
        }  
    }  
}  
```

!!! warning "API Key Required"
    Replace `your-api-key-here` with your actual API key from the [kluster.ai platform](https://platform.kluster.ai){target=_blank}.

## Setup by IDE

=== "Windsurf"

    **Configuration steps**
    
    1. Open **Settings** by clicking the gear icon or using the command palette.
    
    2. Click **Windsurf Settings**.
    
    3. Navigate to **Cascade** in the left sidebar.
    
    4. Select **Manage MCPs** to access the MCP configuration.
    
    5. Click **View raw config** to open `mcp_config.json`.
    
    6. Add the Kluster MCP configuration shown above.
    
    7. Save the configuration and refresh.
    
    **Verification**
    
    The **Kluster-Verify-Code-MCP** will appear with both tools enabled:

    - **`kluster_code_review_auto`**: For code security and quality verification.
    - **`kluster_dependency_validator`**: For dependency validation.
    
    ![Active MCP Tools in Windsurf](/images/verify/code/integrations/windsurf/windsurf-integration-5.webp)

=== "Kilo Code"

    **Configuration steps**
    
    1. Open **Settings** and navigate to **MCP Servers**.
    
    2. Select the **Installed** tab.
    
    3. Click **Edit Project MCP** to open the MCP configuration.
    
    4. Add the Kluster MCP configuration shown above with your API key.
    
    5. Save and restart Kilo Code.
    
    **Verification**
    
    You should see the **Kluster-Verify-Code-MCP** server with both tools enabled:

    - **`kluster_code_review_auto`**: For code security and quality verification.
    - **`kluster_dependency_validator`**: For dependency validation.
    
    ![Kluster MCP Tools in Kilo Code](/images/verify/code/integrations/kilo/kilo-integration-2.webp)

=== "Cline"

    **Configuration steps**
    
    1. Open Cline and click **MCP Servers** in the left sidebar.
    
    2. Select the **Installed** tab.
    
    3. Click **Configure MCP Servers** to open `cline_mcp_settings.json`.
    
    4. Add the Kluster MCP configuration shown above.
    
    5. Save the configuration.
    
    **Verification**
    
    The **Kluster-Verify-Code-MCP** server will appear with both tools enabled:

    - **`kluster_code_review_auto`**: For code security and quality verification.
    - **`kluster_dependency_validator`**: For dependency validation.
    
    ![MCP Configuration in Cline](/images/verify/code/integrations/cline/cline-integration-2.webp)

=== "Roo Code"

    **Configuration steps**
    
    1. Open Roo Code and click **MCP Servers** in the left sidebar.
    
    2. Click **Edit Project MCP** to open the MCP configuration.
    
    3. The configuration file will open at `.roo/mcp_settings.json`.
    
    4. Add the Kluster MCP configuration shown above.
    
    5. Save the file.
    
    **Verification**
    
    The **Kluster-Verify-Code-MCP** server will appear with both tools enabled:

    - **`kluster_code_review_auto`**: For code security and quality verification.
    - **`kluster_dependency_validator`**: For dependency validation.
    
    ![Active MCP Tools in Roo Code](/images/verify/code/integrations/roocode/roocode-integration-2.webp)

=== "Other IDEs"

    **Generic MCP setup**
    
    For any other MCP-compatible IDE:
    
    1. Locate your IDE's MCP configuration file.
    2. Add the Kluster MCP configuration shown above.
    3. Replace `your-api-key-here` with your actual API key.
    4. Save and restart your IDE if required.
    
    The tools should now be available in your AI assistant.
    
## Next steps

- **[Learn about the tools](/verify/tools/)**: Understand what each tool does.
- **[See examples](/verify/examples/cursor-firebase-nextjs/)**: Walk through real-world scenarios.
- **[Check one click installs IDEs](/verify/integrations/ide/)**: Explore IDEs with enhanced integration.
--- END CONTENT ---

Doc-Content: https://docs.kluster.ai/verify/quickstart/
--- BEGIN CONTENT ---
---
title: Get started with Verify Code
description: Set up kluster.ai Code verification in minutes. Scan AI-generated code for errors, vulnerabilities, and performance issues with Cursor and AI assistants.
---

# Get started with Verify Code

Modern developers increasingly rely on AI coding assistants to accelerate development, but this speed comes with risks. Generated code may contain logic errors, security flaws, or performance issues that compromise application quality and security.

The [kluster.ai](https://www.kluster.ai/){target=\_blank} Code verification service integrates directly into your development workflow, automatically scanning AI-generated code in real-time. It catches potential issues instantly within your IDE, allowing you to ship code confidently while maintaining the speed benefits of AI-assisted development.

## Prerequisites

Before getting started, ensure you have:

-- **A kluster.ai account**: Sign up on the [kluster.ai platform](https://platform.kluster.ai/signup){target=\_blank} if you don't have one.
- **A kluster.ai API key**: After signing in, go to the [**API Keys**](https://platform.kluster.ai/apikeys){target=\_blank} section and create a new key. For detailed instructions, check out the [Get an API key](/verify/get-api-key/){target=\_blank} guide.

## Installation

Choose your preferred IDE to get started with kluster.ai Verify Code in under 30 seconds.

<div class="grid cards" markdown>

-   :cursor-icons8-cursor-ai: __Cursor__

    ---

    Install the extension directly from the Cursor marketplace.

    [:octicons-arrow-right-24: Add to Cursor](/verify/integrations/ide/#__tabbed_1_1){target=\_blank}

-   :material-microsoft-visual-studio-code: __VS Code__

    ---

    Install the extension directly from the VS Code marketplace.

    [:octicons-arrow-right-24: Add to VS Code](/verify/integrations/ide/#__tabbed_1_2){target=\_blank}

-   :simple-claude: __Claude Code__

    ---

    Run a simple script in your terminal to set up Verify Code quickly.

    [:octicons-arrow-right-24: Install Claude Code](/verify/integrations/ide/#__tabbed_1_3){target=\_blank}

-   :octicons-code-24: __Other MCP-compatible IDEs__

    ---

     Instructions for setting up Windsurf, Cline, Roo Code, and other MCP-compatible IDEs.

    [:octicons-arrow-right-24: See integration guides](/verify/integrations/mcp/){target=\_blank}

</div>

## Next steps

- **[View all integrations](/verify/integrations/)**: Set up Verify Code in your preferred IDE.
- **[Learn about the tools](/verify/tools/)**: Understand issue types and priority levels.
- **[See real examples](/verify/examples/cursor-firebase-nextjs/)**: Walk through a complete Firebase migration case study.
--- END CONTENT ---

Doc-Content: https://docs.kluster.ai/verify/tools/
--- BEGIN CONTENT ---
---
title: Code MCP Tools for Verify 
description: Learn how kluster.ai Code MCP tools work: parameters, response formats, issue categories, and settings for real-time code verification.
---

# Tools reference

The [kluster.ai](https://www.kluster.ai/){target=_blank} Code MCP server provides verification tools for checking AI-generated code quality and security. These tools enable real-time code verification directly within your IDE through MCP integration.

It includes:

- **`kluster_code_review_auto`**: Verifies code quality and detects bugs, including logic errors, security issues, and performance problems.
- **`kluster_dependency_validator`**: Validates the security and compliance of packages and dependencies in your code.

These tools share the same set of parameters. This page documents those parameters and the response formats you'll see when using these tools in Cursor, Claude Code, or any MCP-compatible client.

## Parameters

These tools analyze AI-generated code and its dependencies to detect bugs, security vulnerabilities, and other quality issues.

???+ interface "Parameters"

    `code_diff` ++"string"++ <span class="required" markdown>++"required"++</span>

    Unified diff format showing the actual code changes.

    ---

    `user_requests` ++"string"++ <span class="required" markdown>++"required"++</span>

    Chronological sequence of user messages with current request marked as `>>> CURRENT REQUEST:`.

    ---

    `modified_files_path` ++"string"++ <span class="required" markdown>++"required"++</span>

    Full absolute paths of modified files separated by `;`.

## Response fields

All Code verification tools return the same response structure:

- **`isCodeCorrect`**: Boolean indicating if the code has issues.
- **`explanation`**: Summary of all issues found.
- **`issues`**: Array of detected problems with:
  - **`type`**: Issue category (intent, semantic, knowledge, performance, quality, logical, security).
  - **`severity`**: Impact level (critical, high, medium, low).
  - **`priority`**: Execution priority (P0-P5).
  - **`description`**: Brief issue summary.
  - **`explanation`**: Detailed issue explanation.
  - **`actions`**: Recommended fixes.
- **`priority_instructions`**: Execution rules for addressing issues.
- **`agent_todo_list`**: Prioritized list of fixes to apply.

### Example response

```json
{  
    "isCodeCorrect": false,  
    "explanation": "Found 3 issues. 1 critical issue needs immediate attention.",  
    "issues": [  
        {  
            "type": "security",  
            "severity": "critical",  
            "priority": "P2",  
            "description": "SQL injection vulnerability",  
            "explanation": "User input is directly concatenated into SQL query without sanitization.",  
            "actions": "Use parameterized queries or prepared statements."  
        }  
    ],  
    "priority_instructions": "Fix P2 issues before deploying code.",  
    "agent_todo_list": [  
        "P2.1: Fix SQL injection vulnerability by using parameterized queries"  
    ]  
}
```

## Bug check types

Code verification categorizes detected issues into seven distinct types, each targeting specific aspects of code quality and correctness. You have full control over which bug types to check for through simple on/off toggles.

|     Type      |           Description           |                Example                |
|:-------------:|:-------------------------------:|:-------------------------------------:|
|   `intent`    | Code doesn't match user request | User asked for sorting, got filtering |
|  `semantic`   |          Logic errors           |        Missing error handling         |
|  `knowledge`  |    Best practice violations     |       Not following conventions       |
| `performance` |       Performance issues        |        Inefficient algorithms         |
|   `quality`   |      Code quality problems      |        Poor naming, complexity        |
|   `logical`   |          Logic errors           |           Off-by-one errors           |
|  `security`   |    Security vulnerabilities     |          SQL injection risks          |

## Priority system

Code verification assigns priority levels to detected issues, helping you focus on the most critical problems first. The system automatically prioritizes based on issue type and severity.

- **P0-P1**: Intent issues (highest priority) - code doesn't match request.
- **P2**: Critical severity - must fix immediately.
- **P3**: High severity - should fix soon.
- **P4**: Medium severity - nice to fix.
- **P5**: Low severity - optional improvements.

## Configuration settings

You can customize the Code verification behavior through the settings page in your IDE. This allows you to tailor the verification process to your specific needs, such as configuring severity levels for issue reporting, selecting which types of bug checks to perform, and enabling or disabling specific MCP tools to match your development workflow.

![Screenshot of Code verification settings interface showing severity levels and enabled tools configuration options.](/images/verify/code/tools/tools-1.webp)

### Severity settings

Configure the minimum severity level for issue reporting. Set your threshold based on your team's needs: **Low**, **Medium**, **High**, **Critical**.

The ideal setting depends on your use case. For example, a **High** level is a good starting point, but you might want to set it to **Medium** for production code.

### Enabled tools

Choose which MCP tools are active:

- **Bug Check Tool**: For code quality verification.
- **Packages Check Tool**: For dependency security.

## Next steps

- **[Set up integrations](/verify/integrations/ide/)**: Configure IDE integrations to use these tools.
- **[Get started](/verify/quickstart/)**: Follow the quickstart guide for immediate setup.
--- END CONTENT ---

